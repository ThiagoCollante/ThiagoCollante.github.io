<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Multiplayer FPS</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            color: white;
            background-color: #111;
        }
        canvas {
            display: block;
        }
        #info-container {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            font-size: 12px;
            z-index: 10;
        }
        #version-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            font-size: 10px;
            color: #ccc;
            z-index: 10;
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column; /* Center content vertically */
            justify-content: center;
            align-items: center;
        }
        #death-message {
            font-size: 2.5rem;
            font-weight: bold;
            color: #ef5350;
            text-shadow: 2px 2px 4px black;
            margin-bottom: 20px;
            display: none; /* Hidden by default */
        }
        #lobby-ui, #pause-menu {
            width: 90%;
            max-width: 450px;
            padding: 25px;
            background-color: #222;
            border-radius: 12px;
            text-align: center;
            border: 1px solid #444;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        .lobby-input {
            width: 100%;
            box-sizing: border-box;
            padding: 10px;
            margin: 10px 0;
            border-radius: 6px;
            border: 1px solid #555;
            background-color: #333;
            color: white;
            text-align: center;
            font-size: 1rem;
        }
        .lobby-button, .menu-button {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            border-radius: 6px;
            border: none;
            background-color: #4a90e2;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .lobby-button:hover:not(:disabled), .menu-button:hover {
            background-color: #357abd;
        }
        .lobby-button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #lobby-id-display {
            margin-top: 15px;
            font-size: 1.1rem;
            font-weight: bold;
            color: #a5d6a7;
        }
        #error-message {
            color: #ef5350;
            margin-top: 10px;
            min-height: 20px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }
        #crosshair.default-crosshair {
            width: 20px;
            height: 20px;
        }
        #crosshair.default-crosshair::before,
        #crosshair.default-crosshair::after {
            content: '';
            position: absolute;
            background-color: white;
            box-shadow: 0 0 2px 1px rgba(0,0,0,0.5);
        }
        #crosshair.default-crosshair::before {
            left: 50%; top: 0; width: 2px; height: 100%; transform: translateX(-50%);
        }
        #crosshair.default-crosshair::after {
            top: 50%; left: 0; height: 2px; width: 100%; transform: translateY(-50%);
        }
        #crosshair.shotgun-crosshair {
            width: 40px;
            height: 40px;
            background-color: transparent;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 0 2px 1px rgba(0,0,0,0.5);
        }
        #minimapContainer {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
            border: 2px solid white;
            border-radius: 50%;
            overflow: hidden;
            z-index: 101;
            background: rgba(0, 0, 0, 0.3);
        }
        #minimapRenderer {
            width: 100%;
            height: 100%;
        }
        #ammoInfo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            z-index: 100;
            text-align: right;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none;
        }
        #sniperScope, #scopeLines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            pointer-events: none;
            z-index: 102;
        }
        #scopeLines {
            transform: translate(-50%, -50%);
            width: 90vmin;
            height: 90vmin;
            top: 50%;
            left: 50%;
            border-radius: 50%;
            box-shadow: 0 0 0 100vmax rgba(0,0,0,0.8);
        }
        #scopeLines .line {
            position: absolute;
            background-color: white;
            box-shadow: 0 0 3px 1px black;
        }
        #scopeLines .vertical {
            left: 50%; width: 1px; height: 100%; transform: translateX(-50%);
        }
        #scopeLines .horizontal {
            top: 50%; height: 1px; width: 100%; transform: translateY(-50%);
        }
        /* NEW: Health Bar Styles */
        #health-bar-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 4px;
            box-sizing: border-box;
            z-index: 100;
            display: none; /* Hidden by default */
        }
        #health-bar {
            width: 100%;
            height: 100%;
            background-color: #4caf50; /* Green for full health */
            border-radius: 6px;
            transition: width 0.3s ease-out, background-color 0.3s;
        }
        #health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            font-size: 16px;
            text-shadow: 1px 1px 2px black;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="blocker">
        <div id="death-message">YOU DIED</div>
        <div id="lobby-ui">
            <h1 style="font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem;">3D Multiplayer FPS</h1>
            <button id="create-lobby-btn" class="lobby-button" disabled>Create New Game</button>
            <button id="start-local-btn" class="lobby-button" disabled>Start Local Test</button>
            <div id="lobby-id-display"></div>
            <hr style="margin: 20px 0; border-color: #444;">
            <input type="text" id="join-lobby-input" class="lobby-input" placeholder="Enter Game ID" disabled>
            <button id="join-lobby-btn" class="lobby-button" disabled>Join Game</button>
            <p id="error-message">Connecting to server...</p>
        </div>
        <div id="pause-menu" style="display: none;">
            <h1 style="font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem;">Game Paused</h1>
            <button id="resume-btn" class="menu-button">Resume Game</button>
        </div>
    </div>

    <div id="info-container">
        Your User ID: <span id="userId">Loading...</span><br>
        Game ID: <span id="lobbyId">N/A</span>
    </div>
    
    <div id="version-info">v6.2-health</div>
    <div id="minimapContainer">
        <div id="minimapRenderer"></div>
    </div>
    <div id="crosshair"></div>
    <div id="ammoInfo"></div>

    <!-- NEW: Health Bar HTML -->
    <div id="health-bar-container">
        <div id="health-bar"></div>
        <span id="health-text">100 / 100</span>
    </div>

    <div id="sniperScope">
        <div id="scopeLines">
            <div class="line vertical"></div>
            <div class="line horizontal"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // Using a more recent Firebase version for compatibility
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, deleteDoc, getDoc, updateDoc, addDoc } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";

        class MultiplayerFPSGame {
            constructor() {
                this.isGameStarted = false;
                this.isLocalMode = false;
                this.db = null;
                this.auth = null;
                this.userId = null;
                this.appId = null;
                this.currentLobbyId = null;
                this.playerRef = null;
                this.playerMeshes = {};
                this.lastUpdateTime = 0;
                this.updateInterval = 50;

                // NEW: Health properties
                this.maxHealth = 100;
                this.currentHealth = 100;
                this.isDead = false;

                this.initLobbyUI();
                this.initFirebase();
            }

            // --- LOBBY AND SETUP ---

            initLobbyUI() {
                document.getElementById('create-lobby-btn').addEventListener('click', () => this.createLobby());
                document.getElementById('start-local-btn').addEventListener('click', () => this.startGame(null, true));
                document.getElementById('join-lobby-btn').addEventListener('click', () => this.joinLobby(document.getElementById('join-lobby-input').value.toUpperCase()));
                document.getElementById('resume-btn').addEventListener('click', () => this.requestPointerLock());
            }

            async initFirebase() {
                 // IMPORTANT: Replace this with your own Firebase project configuration
                const firebaseConfig = {
                    apiKey: "AIzaSy...",
                    authDomain: "your-project-id.firebaseapp.com",
                    projectId: "your-project-id",
                    storageBucket: "your-project-id.appspot.com",
                    messagingSenderId: "1234567890",
                    appId: "1:1234567890:web:abcdef123456"
                };
                
                // Canvas environment check
                if (typeof __firebase_config !== 'undefined') {
                    Object.assign(firebaseConfig, JSON.parse(__firebase_config));
                }

                this.appId = firebaseConfig.projectId;
                const app = initializeApp(firebaseConfig);
                this.db = getFirestore(app);
                this.auth = getAuth(app);

                onAuthStateChanged(this.auth, user => {
                    if (user) {
                        this.userId = user.uid;
                        document.getElementById('userId').textContent = this.userId.substring(0, 8);
                        ['create-lobby-btn', 'join-lobby-btn', 'join-lobby-input', 'start-local-btn'].forEach(id => document.getElementById(id).disabled = false);
                        document.getElementById('error-message').textContent = 'Connected!';
                        setTimeout(() => document.getElementById('error-message').textContent = '', 2000);
                    }
                });
                try { await signInAnonymously(this.auth); } catch (error) { console.error("Firebase sign-in error:", error); }
            }

            async createLobby() {
                const lobbyId = Math.random().toString(36).substring(2, 8).toUpperCase();
                const lobbyRef = doc(this.db, `/artifacts/${this.appId}/public/data/lobbies`, lobbyId);
                await setDoc(lobbyRef, { createdAt: Date.now(), owner: this.userId });
                document.getElementById('lobby-id-display').textContent = `Game ID: ${lobbyId}`;
                this.startGame(lobbyId, false, true);
            }

            async joinLobby(lobbyId) {
                if (!lobbyId) {
                    document.getElementById('error-message').textContent = 'Please enter a Game ID.';
                    return;
                }
                const lobbyRef = doc(this.db, `/artifacts/${this.appId}/public/data/lobbies`, lobbyId);
                if ((await getDoc(lobbyRef)).exists()) {
                    this.startGame(lobbyId, false, false);
                } else {
                    document.getElementById('error-message').textContent = 'Game not found.';
                }
            }

            // --- GAME INITIALIZATION ---

            startGame(lobbyId, isLocal, isHost = false) {
                if (this.isGameStarted) return;
                this.isGameStarted = true;
                this.isLocalMode = isLocal;
                this.currentLobbyId = lobbyId;

                document.getElementById('lobby-ui').style.display = 'none';
                document.getElementById('blocker').style.display = 'none';
                document.getElementById('lobbyId').textContent = isLocal ? 'Local Test' : lobbyId;
                document.getElementById('ammoInfo').style.display = 'block';
                document.getElementById('health-bar-container').style.display = 'block'; // NEW

                this.initScene();
                this.initWorld(); // Must be before initCamera
                this.initCamera();
                this.initWeapons();
                this.initRenderer();
                this.initMinimap();
                this.initLighting();
                this.initPhysics();
                this.initControls();
                
                this.updateCrosshair();
                this.updateAmmoUI();
                this.updateHealthUI(); // NEW

                if (!isLocal) {
                    const playersCollectionPath = `/artifacts/${this.appId}/public/data/lobbies/${this.currentLobbyId}/players`;
                    this.playerRef = doc(this.db, playersCollectionPath, this.userId);
                    setDoc(this.playerRef, { 
                        x: this.camera.position.x, y: this.camera.position.y, z: this.camera.position.z, 
                        qx: 0, qy: 0, qz: 0, qw: 1,
                        health: this.currentHealth // MODIFIED
                    });
                    this.listenForPlayers(playersCollectionPath);
                    this.listenForDamageEvents(); // NEW
                }
                
                this.requestPointerLock();
                this.animate();
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 150, 500);
                this.raycaster = new THREE.Raycaster();
                this.bulletDecals = [];
                this.bulletTrails = [];
                this.shootableObjects = [];
                this.collidableObjects = [];
            }

            initCamera() {
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.spawnPoint = this.getStartPosition(); // MODIFIED
                this.camera.position.set(this.spawnPoint.x, 10, this.spawnPoint.z);
                this.initialRotation = Math.PI;
                this.scene.add(this.camera);
                this.defaultFov = 75;
                this.zoomFov = 20;
                this.isZoomed = false;

                this.playerModel = this.createPlayerModel(0x00ff00, true);
                this.scene.add(this.playerModel);
            }
            
            initWeapons() {
                this.weapons = [ this.createPistol(), this.createShotgun(), this.createSniper() ];
                this.currentWeaponIndex = 0;
                this.lastShotTime = 0;
                this.weapons.forEach((weapon, index) => {
                    this.camera.add(weapon.viewModel);
                    weapon.viewModel.visible = (index === this.currentWeaponIndex);
                });
            }

            createPlayerModel(color, isLocalPlayer = false) {
                const playerGroup = new THREE.Group();
                // A taller cylinder for the player body
                const playerGeo = new THREE.CylinderGeometry(1, 1, 4, 24); 
                const playerMat = new THREE.MeshStandardMaterial({ color, metalness: 0.3, roughness: 0.5 });
                const playerCylinder = new THREE.Mesh(playerGeo, playerMat);
                playerCylinder.castShadow = true;
                playerCylinder.position.y = 2; // Position it so its base is at y=0
                playerGroup.add(playerCylinder);
                
                // Add reference from the mesh back to the main group for hit detection
                playerCylinder.userData.playerGroup = playerGroup;

                if (isLocalPlayer) {
                    playerGroup.visible = false; // The local player doesn't see their own body
                }
                return playerGroup;
            }

            createPistol() {
                const viewModel = new THREE.Group();
                const material = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.4 });
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 1), material);
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.8, 16), material);
                barrel.position.set(0, 0.05, -0.9);
                barrel.rotation.x = Math.PI / 2;
                viewModel.add(body, barrel);
                this.setupViewModel(viewModel, new THREE.Vector3(0.3, -0.3, -1.2));
                return {
                    name: 'Pistol', viewModel, maxAmmo: 10, currentAmmo: 10, reloadTime: 1500,
                    fireRate: 250, isReloading: false, recoilAmount: 0, baseRecoil: 0.1,
                    damage: 15, // NEW
                    muzzlePoint: this.createMuzzlePoint(barrel, new THREE.Vector3(0, 0.4, 0))
                };
            }

            createShotgun() {
                const viewModel = new THREE.Group();
                const material = new THREE.MeshStandardMaterial({ color: 0x604020, metalness: 0.6, roughness: 0.5 });
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 1.2), material);
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 1.0, 16), material);
                barrel.position.set(0, 0, -0.7);
                barrel.rotation.x = Math.PI / 2;
                viewModel.add(body, barrel);
                this.setupViewModel(viewModel, new THREE.Vector3(0.3, -0.3, -1.2));
                return {
                    name: 'Shotgun', viewModel, maxAmmo: 5, currentAmmo: 5, reloadTime: 2500,
                    fireRate: 1000, isReloading: false, recoilAmount: 0, baseRecoil: 0.4,
                    pellets: 8, spread: 0.05, damage: 10, // NEW (damage per pellet)
                    muzzlePoint: this.createMuzzlePoint(barrel, new THREE.Vector3(0, 0.5, 0))
                };
            }

            createSniper() {
                const viewModel = new THREE.Group();
                const material = new THREE.MeshStandardMaterial({ color: 0x2d3436, metalness: 0.7, roughness: 0.3 });
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.25, 1.8), material);
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 1.5, 16), material);
                barrel.position.set(0, 0, -1.2);
                barrel.rotation.x = Math.PI / 2;
                viewModel.add(body, barrel);
                this.setupViewModel(viewModel, new THREE.Vector3(0.3, -0.3, -1.2));
                return {
                    name: 'Sniper', viewModel, maxAmmo: 4, currentAmmo: 4, reloadTime: 3000,
                    fireRate: 1500, isReloading: false, recoilAmount: 0, baseRecoil: 0.8,
                    damage: 75, // NEW
                    muzzlePoint: this.createMuzzlePoint(barrel, new THREE.Vector3(0, 0.75, 0))
                };
            }
            
            // --- The rest of the init methods remain largely unchanged ---
            createMuzzlePoint(parent, position) { const muzzlePoint = new THREE.Object3D(); const flashMaterial = new THREE.MeshBasicMaterial({ color: 0xfff5a1, transparent: true, opacity: 0 }); const flashGeometry = new THREE.PlaneGeometry(0.5, 0.5); const muzzleFlash = new THREE.Mesh(flashGeometry, flashMaterial); muzzlePoint.add(muzzleFlash); parent.add(muzzlePoint); muzzlePoint.position.copy(position); muzzlePoint.flash = muzzleFlash; return muzzlePoint; }
            setupViewModel(viewModel, position) { viewModel.position.copy(position); viewModel.basePosition = position.clone(); viewModel.rotation.set(0, 0, 0); viewModel.traverse(child => { if (child.isMesh) { child.castShadow = false; child.receiveShadow = false; } }); }
            initRenderer() { this.renderer = new THREE.WebGLRenderer({ antialias: true }); this.renderer.setSize(window.innerWidth, window.innerHeight); this.renderer.shadowMap.enabled = true; this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; document.body.insertBefore(this.renderer.domElement, document.getElementById('info-container')); }
            initMinimap() { const minimapContainer = document.getElementById('minimapRenderer'); this.minimapRenderer = new THREE.WebGLRenderer({ antialias: true }); this.minimapRenderer.setSize(200, 200); minimapContainer.appendChild(this.minimapRenderer.domElement); const mapSize = Math.max(this.mapGrid.length, this.mapGrid[0].length) * this.tileSize * 0.7; this.minimapCamera = new THREE.OrthographicCamera(-mapSize, mapSize, mapSize, -mapSize, 1, 1000); this.minimapCamera.up = new THREE.Vector3(0, 0, -1); this.minimapCamera.lookAt(new THREE.Vector3(0, -1, 0)); this.scene.add(this.minimapCamera); this.playerIndicator = new THREE.Mesh(new THREE.SphereGeometry(3, 16, 16), new THREE.MeshBasicMaterial({ color: 0xff0000 })); this.scene.add(this.playerIndicator); }
            initLighting() { this.scene.add(new THREE.AmbientLight(0x606060, 1.2)); const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); directionalLight.position.set(50, 100, 50); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; this.scene.add(directionalLight); }
            initPhysics() { this.velocity = new THREE.Vector3(); this.direction = new THREE.Vector3(); this.isOnGround = false; this.playerHeight = 10; this.jumpForce = 0.35; this.gravity = -0.015; this.walkSpeed = 0.3; this.runSpeed = 0.6; this.playerRadius = 1.5; }
            initWorld() { this.mapGrid = [ [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2], [2, 0, 1, 0, 2, 2, 2, 0, 2, 2, 2, 2, 0, 0, 2], [2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2], [2, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 2, 0, 0, 2], [2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [2, 0, 2, 2, 2, 2, 0, 1, 0, 2, 2, 2, 2, 0, 2], [2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 2], [2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 2, 2, 0, 2], [2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [2, 0, 0, 2, 2, 2, 2, 0, 2, 0, 2, 2, 2, 0, 2], [2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 2], [2, 0, 1, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], ]; this.tileSize = 20; this.generateWorldFromGrid(); }
            initControls() { this.keys = {}; this.mouse = { x: this.initialRotation, y: 0 }; this.isPointerLocked = false; document.addEventListener('keydown', (e) => { this.keys[e.code] = true; if (e.code === 'KeyR') this.reload(); }); document.addEventListener('keyup', (e) => { this.keys[e.code] = false; }); document.addEventListener('mousedown', (e) => { if (!this.isPointerLocked) { this.requestPointerLock(); } else { if (e.button === 0) this.shoot(); else if (e.button === 2) this.toggleZoom(); } }); this.renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault()); document.addEventListener('pointerlockchange', () => { this.isPointerLocked = document.pointerLockElement === this.renderer.domElement; document.getElementById('pause-menu').style.display = this.isPointerLocked ? 'none' : 'block'; document.getElementById('lobby-ui').style.display = 'none'; document.getElementById('blocker').style.display = this.isPointerLocked || this.isDead ? 'none' : 'flex'; if (!this.isPointerLocked && this.isZoomed) this.toggleZoom(); }); document.addEventListener('mousemove', (e) => { if (this.isPointerLocked) { const sensitivity = 0.002; this.mouse.x -= e.movementX * sensitivity; this.mouse.y -= e.movementY * sensitivity; this.mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.mouse.y)); } }); document.addEventListener('wheel', (e) => { if (!this.isPointerLocked) return; if (this.isZoomed) this.toggleZoom(); const currentWeapon = this.weapons[this.currentWeaponIndex]; if (currentWeapon.isReloading) return; currentWeapon.viewModel.visible = false; const direction = e.deltaY > 0 ? 1 : -1; this.currentWeaponIndex = (this.currentWeaponIndex + direction + this.weapons.length) % this.weapons.length; this.weapons[this.currentWeaponIndex].viewModel.visible = true; this.updateCrosshair(); this.updateAmmoUI(); }); window.addEventListener('resize', () => { this.camera.aspect = window.innerWidth / window.innerHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(window.innerWidth, window.innerHeight); }); }

            // --- CORE GAME LOOP AND UPDATES ---
            
            animate() {
                requestAnimationFrame(() => this.animate());
                if (!this.clock) this.clock = new THREE.Clock();
                const delta = this.clock.getDelta();
                const elapsedTime = this.clock.getElapsedTime();

                this.updateCameraRotation();
                if (this.isPointerLocked && !this.isDead) { // MODIFIED
                    this.updatePlayerMovement(delta);
                }
                this.updateViewModel(elapsedTime);
                this.updateEffects();
                this.updateMinimap();

                if (!this.isLocalMode) {
                    this.updateRemotePlayers(delta);
                    const time = performance.now();
                    if (time - this.lastUpdateTime > this.updateInterval) {
                        this.sendPlayerStateToServer();
                        this.lastUpdateTime = time;
                    }
                }
                this.renderer.render(this.scene, this.camera);
            }
            
            // --- Player Movement, Camera, ViewModel and Effects updates remain the same ---
            updatePlayerMovement(delta) { const currentSpeed=(this.keys['ShiftLeft']||this.keys['ShiftRight'])?this.runSpeed:this.walkSpeed; this.direction.set(0,0,0); if(this.keys['KeyW'])this.direction.z=1; if(this.keys['KeyS'])this.direction.z=-1; if(this.keys['KeyA'])this.direction.x=1; if(this.keys['KeyD'])this.direction.x=-1; this.velocity.y+=this.gravity; if(this.keys['Space']&&this.isOnGround){this.velocity.y=this.jumpForce; this.isOnGround=false;} if(this.direction.lengthSq()>0){this.direction.normalize(); const cameraDirection=new THREE.Vector3(); this.camera.getWorldDirection(cameraDirection); cameraDirection.y=0; cameraDirection.normalize(); const right=new THREE.Vector3().crossVectors(this.camera.up,cameraDirection).normalize(); const moveVector=new THREE.Vector3().addScaledVector(cameraDirection,this.direction.z).addScaledVector(right,this.direction.x).normalize().multiplyScalar(currentSpeed); this.velocity.x=moveVector.x; this.velocity.z=moveVector.z;}else{this.velocity.x*=0.9; this.velocity.z*=0.9;} const deltaPosition=this.velocity.clone().multiplyScalar(delta*60); this.handleCollisions(deltaPosition); this.camera.position.add(deltaPosition); if(this.camera.position.y<this.playerHeight){this.camera.position.y=this.playerHeight; this.velocity.y=0; this.isOnGround=true;} this.playerModel.position.copy(this.camera.position); this.playerModel.quaternion.copy(this.camera.quaternion); }
            updateCameraRotation() { this.camera.rotation.order = 'YXZ'; this.camera.rotation.y = this.mouse.x; this.camera.rotation.x = this.mouse.y; }
            updateViewModel(elapsedTime) { const weapon = this.weapons[this.currentWeaponIndex]; const viewModel = weapon.viewModel; viewModel.position.z = viewModel.basePosition.z + weapon.recoilAmount; weapon.recoilAmount *= 0.8; }
            updateEffects() { const now = Date.now(); this.bulletTrails = this.bulletTrails.filter(trail => { const age = now - trail.createdAt; if (age > 200) { this.scene.remove(trail.line); return false; } trail.line.material.opacity = 1.0 * (1 - age / 200); return true; }); this.bulletDecals = this.bulletDecals.filter(decal => { const age = now - decal.createdAt; if (age > 5000) { this.scene.remove(decal.mesh); return false; } decal.mesh.material.opacity = 0.8 * (1 - age / 5000); return true; }); }
            updateMinimap() { this.minimapCamera.position.set(this.camera.position.x, 150, this.camera.position.z); this.playerIndicator.position.copy(this.camera.position); this.playerIndicator.position.y = 1; this.minimapRenderer.render(this.scene, this.minimapCamera); }

            // --- ACTIONS (SHOOTING, RELOADING, ETC.) ---

            shoot() {
                const weapon = this.weapons[this.currentWeaponIndex];
                const now = performance.now();
                if (this.isDead || weapon.isReloading || weapon.currentAmmo <= 0 || now - this.lastShotTime < weapon.fireRate) return; // MODIFIED
                
                if (this.isZoomed && weapon.name !== 'Sniper') this.toggleZoom();

                this.lastShotTime = now;
                weapon.currentAmmo--;
                this.updateAmmoUI();
                weapon.recoilAmount = weapon.baseRecoil;
                weapon.muzzlePoint.flash.material.opacity = 1;
                setTimeout(() => { weapon.muzzlePoint.flash.material.opacity = 0; }, 60);

                const pellets = weapon.name === 'Shotgun' ? weapon.pellets : 1;
                for (let i = 0; i < pellets; i++) {
                    this.fireBullet(weapon.spread || 0);
                }
                if (weapon.currentAmmo === 0) this.reload();
            }
            
            fireBullet(spread) {
                const spreadDirection = new THREE.Vector2((Math.random() - 0.5) * spread, (Math.random() - 0.5) * spread);
                this.raycaster.setFromCamera(spreadDirection, this.camera);
                
                // MODIFIED: Raycast against players and world
                const remotePlayerMeshes = Object.values(this.playerMeshes).map(p => p.mesh);
                const intersects = this.raycaster.intersectObjects([...this.shootableObjects, ...remotePlayerMeshes], true);

                if (intersects.length > 0) {
                    const intersection = intersects[0];
                    this.createBulletTrail(intersection.point);

                    const hitObject = intersection.object;
                    // NEW: Check if we hit a player
                    if (hitObject.userData.playerGroup && hitObject.userData.playerGroup.userData.playerId) {
                        const targetId = hitObject.userData.playerGroup.userData.playerId;
                        if (targetId !== this.userId && !this.isLocalMode) {
                            this.sendDamageEvent(targetId, this.weapons[this.currentWeaponIndex].damage);
                        }
                    } else { // We hit the world
                       if (intersection.face) this.createBulletDecal(intersection.point, intersection.face.normal);
                    }
                } else {
                    const endPoint = new THREE.Vector3();
                    this.raycaster.ray.at(1000, endPoint);
                    this.createBulletTrail(endPoint);
                }
            }
            
            // --- The rest of the actions and effects remain the same ---
            createBulletTrail(endPoint) { const weapon = this.weapons[this.currentWeaponIndex]; const startPoint = new THREE.Vector3(); weapon.muzzlePoint.getWorldPosition(startPoint); const points = [startPoint, endPoint]; const geometry = new THREE.BufferGeometry().setFromPoints(points); const material = new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 1.0 }); const trail = new THREE.Line(geometry, material); this.scene.add(trail); this.bulletTrails.push({ line: trail, createdAt: Date.now() }); }
            createBulletDecal(position, normal) { const decalMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.8, depthTest: true, depthWrite: false }); const decalGeometry = new THREE.PlaneGeometry(0.2, 0.2); const decal = new THREE.Mesh(decalGeometry, decalMaterial); decal.position.copy(position); decal.lookAt(position.clone().add(normal)); decal.position.add(normal.multiplyScalar(0.01)); this.scene.add(decal); this.bulletDecals.push({ mesh: decal, createdAt: Date.now() }); }
            reload() { const weapon = this.weapons[this.currentWeaponIndex]; if (weapon.isReloading || weapon.currentAmmo === weapon.maxAmmo) return; if (this.isZoomed) this.toggleZoom(); weapon.isReloading = true; this.updateAmmoUI(); setTimeout(() => { weapon.currentAmmo = weapon.maxAmmo; weapon.isReloading = false; this.updateAmmoUI(); }, weapon.reloadTime); }
            toggleZoom() { const weapon = this.weapons[this.currentWeaponIndex]; if (weapon.name !== 'Sniper' || weapon.isReloading) return; this.isZoomed = !this.isZoomed; this.camera.fov = this.isZoomed ? this.zoomFov : this.defaultFov; this.camera.updateProjectionMatrix(); document.getElementById('sniperScope').style.display = this.isZoomed ? 'block' : 'none'; document.getElementById('scopeLines').style.display = this.isZoomed ? 'block' : 'none'; document.getElementById('crosshair').style.display = this.isZoomed ? 'none' : 'block'; weapon.viewModel.visible = !this.isZoomed; }

            // --- NEW: Health and Damage Logic ---

            takeDamage(damage) {
                if (this.isDead) return;
                this.currentHealth -= damage;
                this.currentHealth = Math.max(0, this.currentHealth);
                this.updateHealthUI();
                
                // Update our health state in Firebase for others to see
                if (this.playerRef) {
                    updateDoc(this.playerRef, { health: this.currentHealth });
                }

                if (this.currentHealth <= 0) {
                    this.die();
                }
            }

            die() {
                this.isDead = true;
                const deathMessage = document.getElementById('death-message');
                const blocker = document.getElementById('blocker');
                deathMessage.style.display = 'block';
                blocker.style.backgroundColor = 'rgba(150, 20, 20, 0.5)';
                blocker.style.display = 'flex';
                
                if (this.isZoomed) this.toggleZoom();
                
                setTimeout(() => this.respawn(), 3000); // Respawn after 3 seconds
            }

            respawn() {
                this.isDead = false;
                this.currentHealth = this.maxHealth;
                this.updateHealthUI();
                
                this.camera.position.set(this.spawnPoint.x, this.playerHeight, this.spawnPoint.z);
                this.velocity.set(0, 0, 0);

                const deathMessage = document.getElementById('death-message');
                const blocker = document.getElementById('blocker');
                deathMessage.style.display = 'none';
                blocker.style.backgroundColor = 'rgba(0,0,0,0.7)';
                
                // If the pause menu isn't up, hide the blocker and re-lock pointer
                if (document.pointerLockElement !== this.renderer.domElement) {
                    this.requestPointerLock();
                } else {
                     blocker.style.display = 'none';
                }

                if (this.playerRef) {
                    updateDoc(this.playerRef, {
                        health: this.currentHealth,
                        x: this.camera.position.x,
                        y: this.camera.position.y,
                        z: this.camera.position.z,
                    });
                }
            }

            // --- MULTIPLAYER ---

            async sendDamageEvent(targetId, damage) {
                const damageEventsPath = `/artifacts/${this.appId}/public/data/lobbies/${this.currentLobbyId}/damageEvents`;
                await addDoc(collection(this.db, damageEventsPath), {
                    targetId,
                    damage,
                    shooterId: this.userId,
                    timestamp: Date.now()
                });
            }
            
            listenForDamageEvents() {
                const damageEventsPath = `/artifacts/${this.appId}/public/data/lobbies/${this.currentLobbyId}/damageEvents`;
                onSnapshot(collection(this.db, damageEventsPath), (snapshot) => {
                    snapshot.docChanges().forEach(async (change) => {
                        if (change.type === "added") {
                            const eventData = change.doc.data();
                            // Only process recent events and if we are the target
                            if (Date.now() - eventData.timestamp < 5000 && eventData.targetId === this.userId) {
                                this.takeDamage(eventData.damage);
                                // Optional: Delete the event doc after processing to keep the collection clean
                                await deleteDoc(doc(this.db, damageEventsPath, change.doc.id));
                            }
                        }
                    });
                });
            }

            sendPlayerStateToServer() {
                if (this.playerRef) {
                    const data = {
                        x: this.camera.position.x, y: this.camera.position.y, z: this.camera.position.z,
                        qx: this.camera.quaternion.x, qy: this.camera.quaternion.y, qz: this.camera.quaternion.z, qw: this.camera.quaternion.w
                    };
                    // Only send health if it's not already being sent by takeDamage
                    if (!this.isDead && this.currentHealth === this.maxHealth) {
                        data.health = this.currentHealth;
                    }
                    updateDoc(this.playerRef, data);
                }
            }

            listenForPlayers(collectionPath) {
                onSnapshot(collection(this.db, collectionPath), (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        const docId = change.doc.id;
                        if (docId === this.userId) return; // Skip our own player
                        const data = change.doc.data();
                        let player = this.playerMeshes[docId];

                        if (change.type === "added" && !player) {
                            const model = this.createPlayerModel(Math.random() * 0xffffff);
                            model.userData.playerId = docId; // Assign ID
                            this.playerMeshes[docId] = { mesh: model, targetPosition: new THREE.Vector3(), targetQuaternion: new THREE.Quaternion() };
                            this.scene.add(model);
                        } else if (change.type === "removed" && player) {
                            this.scene.remove(player.mesh);
                            delete this.playerMeshes[docId];
                            return;
                        }
                        
                        player = this.playerMeshes[docId];
                        if (player && data) {
                            player.targetPosition.set(data.x, data.y, data.z);
                            if (data.qx !== undefined) {
                                player.targetQuaternion.set(data.qx, data.qy, data.qz, data.qw);
                            }
                             // MODIFIED: Show/hide player based on health
                            player.mesh.visible = (data.health > 0);
                        }
                    });
                });
            }

            updateRemotePlayers(delta) {
                const factor = delta * 15; // Increased lerp factor for smoother movement
                for (const id in this.playerMeshes) {
                    const player = this.playerMeshes[id];
                    player.mesh.position.lerp(player.targetPosition, factor);
                    player.mesh.quaternion.slerp(player.targetQuaternion, factor);
                }
            }

            // --- UTILITIES AND HELPERS ---
            handleCollisions(deltaPosition) { const playerSphere = new THREE.Sphere(this.camera.position, this.playerRadius); for (const obj of this.collidableObjects) { const nextPlayerSphere = new THREE.Sphere(playerSphere.center.clone().add(deltaPosition), playerSphere.radius); if (obj.type === 'box' && nextPlayerSphere.intersectsBox(obj.bounds)) { const closestPoint = new THREE.Vector3().copy(nextPlayerSphere.center).clamp(obj.bounds.min, obj.bounds.max); const penetrationVector = new THREE.Vector3().subVectors(nextPlayerSphere.center, closestPoint).normalize(); const dot = deltaPosition.dot(penetrationVector); if (dot < 0) deltaPosition.sub(penetrationVector.multiplyScalar(dot)); } else if (obj.type === 'sphere' && nextPlayerSphere.intersectsSphere(obj.bounds)) { const penetrationVector = new THREE.Vector3().subVectors(nextPlayerSphere.center, obj.bounds.center).normalize(); const dot = deltaPosition.dot(penetrationVector); if (dot < 0) deltaPosition.sub(penetrationVector.multiplyScalar(dot)); } } }
            generateWorldFromGrid() { const wallHeight = this.tileSize; const gridWidth = this.mapGrid[0].length * this.tileSize; const gridDepth = this.mapGrid.length * this.tileSize; const offsetX = -gridWidth / 2; const offsetZ = -gridDepth / 2; const groundGeometry = new THREE.PlaneGeometry(gridWidth, gridDepth); const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x66aa66 }); const ground = new THREE.Mesh(groundGeometry, groundMaterial); ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true; this.scene.add(ground); this.shootableObjects.push(ground); this.mapGrid.forEach((row, z) => { row.forEach((tileType, x) => { const worldX = offsetX + x * this.tileSize + this.tileSize / 2; const worldZ = offsetZ + z * this.tileSize + this.tileSize / 2; switch (tileType) { case 1: const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, 8), new THREE.MeshLambertMaterial({ color: 0x8B4513 })); trunk.position.set(worldX, 4, worldZ); trunk.castShadow = true; this.scene.add(trunk); const leaves = new THREE.Mesh(new THREE.SphereGeometry(4, 8, 8), new THREE.MeshLambertMaterial({ color: 0x228B22 })); leaves.position.set(worldX, 8 + 2, worldZ); leaves.castShadow = true; this.scene.add(leaves); this.collidableObjects.push({ mesh: trunk, type: 'sphere', bounds: new THREE.Sphere(trunk.position, 1.5) }); this.shootableObjects.push(trunk, leaves); break; case 2: const wall = new THREE.Mesh(new THREE.BoxGeometry(this.tileSize, wallHeight, this.tileSize), new THREE.MeshLambertMaterial({ color: new THREE.Color(0.5, 0.5, 0.5) })); wall.position.set(worldX, wallHeight / 2, worldZ); wall.castShadow = true; wall.receiveShadow = true; this.scene.add(wall); const box = new THREE.Box3().setFromObject(wall); this.collidableObjects.push({ mesh: wall, type: 'box', bounds: box }); this.shootableObjects.push(wall); break; } }); }); }
            getStartPosition() { const openSpots = []; const gridWidth = this.mapGrid[0].length * this.tileSize; const gridDepth = this.mapGrid.length * this.tileSize; const offsetX = -gridWidth / 2; const offsetZ = -gridDepth / 2; for (let z = 0; z < this.mapGrid.length; z++) { for (let x = 0; x < this.mapGrid[z].length; x++) { if (this.mapGrid[z][x] === 0) { openSpots.push({ x: offsetX + x * this.tileSize + this.tileSize / 2, z: offsetZ + z * this.tileSize + this.tileSize / 2 }); } } } return openSpots.length > 0 ? openSpots[Math.floor(Math.random() * openSpots.length)] : { x: 0, z: 0 }; }
            requestPointerLock() { this.renderer.domElement.requestPointerLock(); }
            updateCrosshair() { const weapon = this.weapons[this.currentWeaponIndex]; const crosshair = document.getElementById('crosshair'); crosshair.className = ''; switch(weapon.name) { case 'Shotgun': crosshair.classList.add('shotgun-crosshair'); break; default: crosshair.classList.add('default-crosshair'); break; } crosshair.style.display = this.isDead ? 'none' : 'block'; }
            updateAmmoUI() { const weapon = this.weapons[this.currentWeaponIndex]; const ammoElem = document.getElementById('ammoInfo'); if (weapon.isReloading) { ammoElem.innerHTML = `Reloading...`; } else { ammoElem.innerHTML = `${weapon.currentAmmo} / ${weapon.maxAmmo}`; } }

            updateHealthUI() {
                const healthBar = document.getElementById('health-bar');
                const healthText = document.getElementById('health-text');
                const percentage = (this.currentHealth / this.maxHealth) * 100;
                
                healthBar.style.width = `${percentage}%`;
                // Change color based on health
                if (percentage > 60) healthBar.style.backgroundColor = '#4caf50'; // Green
                else if (percentage > 30) healthBar.style.backgroundColor = '#ffc107'; // Yellow
                else healthBar.style.backgroundColor = '#f44336'; // Red
                
                healthText.textContent = `${this.currentHealth} / ${this.maxHealth}`;
            }
        }

        window.onload = () => new MultiplayerFPSGame();
    </script>
</body>
</html>

