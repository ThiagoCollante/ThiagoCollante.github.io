<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Multiplayer FPS</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            color: white;
            background-color: #111;
        }
        canvas {
            display: block;
        }
        #info-container {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            font-size: 12px;
            z-index: 10;
        }
        #version-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            font-size: 10px;
            color: white;
            z-index: 10;
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #lobby-ui, #pause-menu, #match-lobby-ui, #username-ui {
            width: 90%;
            max-width: 450px;
            padding: 25px;
            background-color: #222;
            border-radius: 12px;
            text-align: center;
            border: 1px solid #444;
        }
        .lobby-input {
            width: 100%;
            box-sizing: border-box;
            padding: 10px;
            margin: 10px 0;
            border-radius: 6px;
            border: 1px solid #555;
            background-color: #333;
            color: white;
            text-align: center;
            font-size: 1rem;
        }
        .lobby-button, .menu-button {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            border-radius: 6px;
            border: none;
            background-color: #4a90e2;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .lobby-button:hover:not(:disabled), .menu-button:hover {
            background-color: #357abd;
        }
        .lobby-button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #lobby-id-display, #match-lobby-title {
            margin-top: 15px;
            font-size: 1.1rem;
            font-weight: bold;
            color: #a5d6a7;
        }
        #error-message {
            color: #ef5350;
            margin-top: 10px;
            min-height: 20px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            display: none;
        }
        #crosshair.default-crosshair {
            width: 20px;
            height: 20px;
        }
        #crosshair.default-crosshair::before,
        #crosshair.default-crosshair::after {
            content: '';
            position: absolute;
            background-color: white;
            box-shadow: 0 0 2px 1px rgba(0,0,0,0.5);
        }
        #crosshair.default-crosshair::before {
            left: 50%; top: 0; width: 2px; height: 100%; transform: translateX(-50%);
        }
        #crosshair.default-crosshair::after {
            top: 50%; left: 0; height: 2px; width: 100%; transform: translateY(-50%);
        }
        #crosshair.shotgun-crosshair {
            width: 40px;
            height: 40px;
            background-color: transparent;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 0 2px 1px rgba(0,0,0,0.5);
        }
        #minimapContainer {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
            border: 2px solid white;
            border-radius: 50%;
            overflow: hidden;
            z-index: 101;
            background: rgba(0, 0, 0, 0.3);
            display: none; /* Hide by default */
        }
        #minimapRenderer {
            width: 100%;
            height: 100%;
        }
        #ammoInfo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            z-index: 100;
            text-align: right;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none;
        }
        #sniperScope, #scopeLines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            pointer-events: none;
            z-index: 102;
        }
        #scopeLines {
            transform: translate(-50%, -50%);
            width: 90vmin;
            height: 90vmin;
            top: 50%;
            left: 50%;
            border-radius: 50%;
            box-shadow: 0 0 0 100vmax rgba(0,0,0,0.8);
        }
        #scopeLines .line {
            position: absolute;
            background-color: white;
            box-shadow: 0 0 3px 1px black;
        }
        #scopeLines .vertical {
            left: 50%; width: 1px; height: 100%; transform: translateX(-50%);
        }
        #scopeLines .horizontal {
            top: 50%; height: 1px; width: 100%; transform: translateY(-50%);
        }
        #healthBarContainer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 250px;
            height: 30px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 100;
            display: none;
            padding: 2px;
        }
        #healthBar {
            width: 100%;
            height: 100%;
            background-color: #4caf50; /* Green */
            border-radius: 6px;
            transition: width 0.3s ease, background-color 0.3s ease;
        }
        #healthText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        .player-status {
            padding: 10px;
            margin: 5px 0;
            background-color: #333;
            border-radius: 8px;
            border: 1px solid #444;
            font-size: 0.9rem;
        }
        .player-status .status-ready { color: #4caf50; }
        .player-status .status-not-ready { color: #f44336; }
        .team-section {
            margin-bottom: 15px;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 10px;
            background-color: #2a2a2a;
        }
        .team-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 1rem;
        }
        #team-a { color: #64b5f6; } /* Light Blue */
        #team-b { color: #e57373; } /* Light Red */
        .game-mode-selection { margin: 15px 0; }
        .game-mode-selection label { margin: 0 10px; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="blocker">
        <div id="username-ui">
            <h1 class="text-2xl font-bold mb-4">Enter Your Name</h1>
            <input type="text" id="username-input" class="lobby-input" placeholder="Username" maxlength="12">
            <button id="username-btn" class="lobby-button">Continue</button>
        </div>
        <div id="lobby-ui" style="display: none;">
            <h1 class="text-2xl font-bold mb-4">Join a Game</h1>
            <div class="game-mode-selection">
                Game Mode:
                <label><input type="radio" name="gameMode" value="1v1" checked> 1 vs 1</label>
                <label><input type="radio" name="gameMode" value="2v2"> 2 vs 2</label>
            </div>
            <button id="create-lobby-btn" class="lobby-button" disabled>Create New Game</button>
            <button id="start-local-btn" class="lobby-button" disabled>Start Local Test</button>
            <div id="lobby-id-display"></div>
            <hr class="my-4" style="margin: 20px 0; border-color: #444;">
            <input type="text" id="join-lobby-input" class="lobby-input" placeholder="Enter Game ID" disabled>
            <button id="join-lobby-btn" class="lobby-button" disabled>Join Game</button>
            <p id="error-message">Initializing...</p>
        </div>
        <div id="match-lobby-ui" style="display: none;">
            <h1 id="match-lobby-title">Waiting for Players...</h1>
            <div class="team-section">
                <div id="team-a" class="team-title">Team A</div>
                <div id="player-slot-0" class="player-status">Slot 1: Waiting...</div>
                <div id="player-slot-2" class="player-status" style="display: none;">Slot 3: Waiting...</div>
            </div>
             <div class="team-section">
                <div id="team-b" class="team-title">Team B</div>
                <div id="player-slot-1" class="player-status">Slot 2: Waiting...</div>
                <div id="player-slot-3" class="player-status" style="display: none;">Slot 4: Waiting...</div>
            </div>
            <button id="ready-btn" class="menu-button">Ready Up</button>
        </div>
        <div id="pause-menu" style="display: none;">
            <h1 class="text-2xl font-bold mb-4">Game Paused</h1>
            <button id="resume-btn" class="menu-button">Resume Game</button>
            <button id="quit-btn" class="menu-button">Quit Match</button>
        </div>
    </div>

    <div id="info-container">
        Your User ID: <span id="userId">Loading...</span><br>
        Game ID: <span id="lobbyId">N/A</span>
    </div>
    
    <div id="version-info">Version 7.4-team_lobby</div>
    <div id="minimapContainer">
        <div id="minimapRenderer"></div>
    </div>
    <div id="crosshair"></div>
    <div id="ammoInfo"></div>
    <div id="sniperScope">
        <div id="scopeLines">
            <div class="line vertical"></div>
            <div class="line horizontal"></div>
        </div>
    </div>
    <div id="healthBarContainer">
        <div id="healthBar"></div>
        <span id="healthText">100 / 100</span>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, deleteDoc, getDoc, updateDoc, addDoc, getDocs, query, where, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        class MultiplayerFPSGame {
            constructor() {
                this.isGameStarted = false;
                this.isLocalMode = false;
                this.db = null;
                this.auth = null;
                this.userId = null;
                this.username = null;
                this.appId = null;
                this.currentLobbyId = null;
                this.playerRef = null;
                this.playerMeshes = {};
                this.lastUpdateTime = 0;
                this.updateInterval = 50;
                this.health = 100;
                this.animationFrameId = null;
                this.playerReady = false;
                this.playerIndex = 0; // 0 for host, 1 for guest
                this.team = 'A'; // Default team
                this.gameMode = '1v1'; // Default game mode
                this.maxPlayers = 2;
                this.playerDataCache = {}; // Cache player data like team

                this.initLobbyUI();
                this.initFirebase();
            }

            // --- LOBBY AND SETUP ---

            initLobbyUI() {
                document.getElementById('username-btn').addEventListener('click', () => this.setUsername());
                document.getElementById('create-lobby-btn').addEventListener('click', () => this.createLobby());
                document.getElementById('start-local-btn').addEventListener('click', () => this.startGame(null, true));
                document.getElementById('join-lobby-btn').addEventListener('click', () => this.joinLobby(document.getElementById('join-lobby-input').value.toUpperCase()));
                document.getElementById('resume-btn').addEventListener('click', () => this.requestPointerLock());
                document.getElementById('quit-btn').addEventListener('click', () => this.quitMatch());
                document.getElementById('ready-btn').addEventListener('click', () => this.toggleReady());
            }

            setUsername() {
                const usernameInput = document.getElementById('username-input');
                const username = usernameInput.value.trim();
                if (username) {
                    this.username = username;
                    document.getElementById('username-ui').style.display = 'none';
                    document.getElementById('lobby-ui').style.display = 'block';
                } else {
                    usernameInput.placeholder = 'Please enter a name!';
                }
            }

            async initFirebase() {
                 // **FIX:** Uncommented the firebaseConfig object
                const firebaseConfig = {
                    apiKey: "AIzaSyBX7Qk3hB7vNykKt9WyiDNWrqq0eXxpGMA",
                    authDomain: "lanhtml-d905d.firebaseapp.com",
                    projectId: "lanhtml-d905d",
                    storageBucket: "lanhtml-d905d.appspot.com",
                    messagingSenderId: "427246041879",
                    appId: "1:427246041879:web:b455c681ee7b952edc9552"
                };
                this.appId = firebaseConfig.projectId;
                const app = initializeApp(firebaseConfig); // Pass the config object here
                this.db = getFirestore(app);
                this.auth = getAuth(app);

                onAuthStateChanged(this.auth, user => {
                    if (user) {
                        this.userId = user.uid;
                        document.getElementById('userId').textContent = this.userId.substring(0, 8);
                        ['create-lobby-btn', 'join-lobby-btn', 'join-lobby-input', 'start-local-btn'].forEach(id => document.getElementById(id).disabled = false);
                        
                        const errorMessage = document.getElementById('error-message');
                        errorMessage.textContent = 'Ready!';
                        errorMessage.style.color = '#a5d6a7';
                        
                        setTimeout(() => {
                           if(errorMessage.textContent === 'Ready!') {
                               errorMessage.textContent = '';
                           }
                        }, 2000);
                    }
                });
                try { await signInAnonymously(this.auth); } catch (error) { console.error("Firebase sign-in error:", error); }
            }

            async createLobby() {
                const lobbyId = Math.random().toString(36).substring(2, 8).toUpperCase();
                const lobbyRef = doc(this.db, `/artifacts/${this.appId}/public/data/lobbies`, lobbyId);
                const selectedMode = document.querySelector('input[name="gameMode"]:checked').value;
                this.gameMode = selectedMode;
                this.maxPlayers = selectedMode === '1v1' ? 2 : 4;
                
                await setDoc(lobbyRef, { 
                    createdAt: Date.now(), 
                    owner: this.userId, 
                    status: 'waiting', 
                    gameMode: this.gameMode, 
                    maxPlayers: this.maxPlayers 
                });
                this.playerIndex = 0; // Host is always index 0
                this.team = 'A'; // Host starts in Team A
                this.enterMatchLobby(lobbyId);
            }

            async joinLobby(lobbyId) {
                if (!lobbyId) {
                    this.showError('Please enter a Game ID.');
                    return;
                }
                const lobbyRef = doc(this.db, `/artifacts/${this.appId}/public/data/lobbies`, lobbyId);
                const lobbySnap = await getDoc(lobbyRef);

                if (!lobbySnap.exists()) {
                    this.showError('Game not found.');
                    return;
                }

                const lobbyData = lobbySnap.data();
                this.gameMode = lobbyData.gameMode || '1v1';
                this.maxPlayers = lobbyData.maxPlayers || 2;

                const playersCollectionPath = `/artifacts/${this.appId}/public/data/lobbies/${lobbyId}/players`;
                const playersSnapshot = await getDocs(collection(this.db, playersCollectionPath));

                if (playersSnapshot.size >= this.maxPlayers) {
                    this.showError('Lobby is full.');
                } else {
                     // Determine player index and team
                    const players = playersSnapshot.docs.map(d => d.data());
                    const teamACount = players.filter(p => p.team === 'A').length;
                    const teamBCount = players.filter(p => p.team === 'B').length;
                    
                    this.playerIndex = playersSnapshot.size; 
                    this.team = teamACount <= teamBCount ? 'A' : 'B';

                    this.enterMatchLobby(lobbyId);
                }
            }
            
            async enterMatchLobby(lobbyId) {
                this.currentLobbyId = lobbyId;
                document.getElementById('lobby-ui').style.display = 'none';
                document.getElementById('match-lobby-ui').style.display = 'block';
                document.getElementById('match-lobby-title').textContent = `Match Lobby: ${lobbyId} (${this.gameMode})`;

                // Show/hide slots based on game mode
                document.getElementById('player-slot-2').style.display = this.gameMode === '2v2' ? 'block' : 'none';
                document.getElementById('player-slot-3').style.display = this.gameMode === '2v2' ? 'block' : 'none';

                const playersCollectionPath = `/artifacts/${this.appId}/public/data/lobbies/${this.currentLobbyId}/players`;
                this.playerRef = doc(this.db, playersCollectionPath, this.userId);
                await setDoc(this.playerRef, { 
                    ready: false, 
                    userId: this.userId, 
                    username: this.username, 
                    team: this.team,
                    playerIndex: this.playerIndex // Store index for spawning
                });
                
                this.listenForPlayers(playersCollectionPath, true);
            }

            async toggleReady() {
                this.playerReady = !this.playerReady;
                if (this.playerRef) {
                    await updateDoc(this.playerRef, { ready: this.playerReady });
                }
                document.getElementById('ready-btn').textContent = this.playerReady ? 'Unready' : 'Ready Up';
            }

             async quitMatch() {
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                this.isGameStarted = false;
                document.exitPointerLock(); // Ensure pointer lock is released

                if (this.playerRef) {
                    await deleteDoc(this.playerRef);
                    this.playerRef = null;
                    const playersCollectionPath = `/artifacts/${this.appId}/public/data/lobbies/${this.currentLobbyId}/players`;
                    const playersSnapshot = await getDocs(collection(this.db, playersCollectionPath));
                    if (playersSnapshot.empty && !this.isLocalMode) { // Only cleanup if not local and lobby empty
                        await this.cleanupLobby(this.currentLobbyId);
                    }
                }
                
                // Reset UI to main lobby state
                document.getElementById('blocker').style.display = 'flex';
                document.getElementById('username-ui').style.display = 'none';
                document.getElementById('lobby-ui').style.display = 'block';
                document.getElementById('match-lobby-ui').style.display = 'none';
                document.getElementById('pause-menu').style.display = 'none';
                ['ammoInfo', 'healthBarContainer', 'minimapContainer'].forEach(id => document.getElementById(id).style.display = 'none');
                
                // Clear scene resources if needed (optional for reload)
                this.clearScene();
                 window.location.reload(); // Simple way to reset state
            }

            async cleanupLobby(lobbyId) {
                if (!lobbyId) return;
                console.log(`Cleaning up lobby: ${lobbyId}`);
                try {
                    // Delete events subcollection first
                    const eventsCollectionPath = `/artifacts/${this.appId}/public/data/lobbies/${lobbyId}/events`;
                    const eventsSnapshot = await getDocs(collection(this.db, eventsCollectionPath));
                    const batch = writeBatch(this.db);
                    eventsSnapshot.forEach(doc => batch.delete(doc.ref));
                    await batch.commit();
                    console.log("Deleted all game events.");

                    // Delete the main lobby document
                    const lobbyRef = doc(this.db, `/artifacts/${this.appId}/public/data/lobbies`, lobbyId);
                    await deleteDoc(lobbyRef);
                    console.log("Deleted lobby document.");
                } catch (e) { console.error("Error cleaning up lobby:", e); }
            }

            // --- GAME INITIALIZATION ---

            startGame(lobbyId, isLocal) {
                 if (this.isGameStarted) return;
                this.isGameStarted = true;
                this.isLocalMode = isLocal;
                this.currentLobbyId = lobbyId;
                this.health = 100;

                document.getElementById('lobby-ui').style.display = 'none';
                document.getElementById('match-lobby-ui').style.display = 'none';
                document.getElementById('blocker').style.display = 'none';
                document.getElementById('lobbyId').textContent = isLocal ? 'Local Test' : lobbyId;
                ['ammoInfo', 'healthBarContainer', 'minimapContainer'].forEach(id => document.getElementById(id).style.display = 'block');

                this.initScene();
                this.initWorld(); // Must be before initCamera
                this.initCamera();
                this.initWeapons();
                this.initRenderer();
                this.initMinimap();
                this.initLighting();
                this.initPhysics();
                this.initControls();
                
                this.updateCrosshair();
                this.updateAmmoUI();
                this.updateHealthUI();

                if (!isLocal) {
                    const playersCollectionPath = `/artifacts/${this.appId}/public/data/lobbies/${this.currentLobbyId}/players`;
                    this.playerRef = doc(this.db, playersCollectionPath, this.userId);
                    const startPos = this.getStartPosition(this.team); // Use team for spawn
                    this.camera.position.set(startPos.x, this.playerHeight, startPos.z);
                    updateDoc(this.playerRef, { 
                        x: startPos.x, y: this.camera.position.y, z: startPos.z, 
                        yaw: this.mouse.x, pitch: this.mouse.y, health: 100
                    });
                    this.listenForPlayers(playersCollectionPath, false); // Switch to game listener
                    this.listenForGameEvents();
                } else {
                     const startPos = this.getStartPosition('A'); // Default spawn for local
                    this.camera.position.set(startPos.x, this.playerHeight, startPos.z);
                }
                
                this.requestPointerLock();
                this.animate();
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 150, 500);
                this.raycaster = new THREE.Raycaster();
                this.bulletDecals = [];
                this.bulletTrails = [];
                this.shootableObjects = [];
                this.collidableObjects = [];
                this.wallMeshes = [];
            }

            initCamera() {
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const startPos = this.getStartPosition(this.team); // Use team-based spawn
                this.camera.position.set(startPos.x, this.playerHeight, startPos.z);
                this.initialRotation = Math.PI;
                this.scene.add(this.camera);
                this.defaultFov = 75;
                this.zoomFov = 20;
                this.isZoomed = false;

                this.playerModel = this.createPlayerModel(0x00ff00, true);
                this.scene.add(this.playerModel);
            }
            
            initWeapons() {
                this.weapons = [ this.createPistol(), this.createShotgun(), this.createSniper() ];
                this.currentWeaponIndex = 0;
                this.lastShotTime = 0;

                this.weapons.forEach((weapon, index) => {
                    this.camera.add(weapon.viewModel);
                    weapon.viewModel.visible = (index === this.currentWeaponIndex);
                });
            }

            createPlayerModel(color, isLocalPlayer = false, team = 'A') {
                const playerGroup = new THREE.Group();
                const cylinderHeight = 3.5;
                const cylinderRadius = 0.8;
                
                const teamColor = team === 'A' ? 0x64b5f6 : 0xe57373; // Blue for A, Red for B

                const bodyGeo = new THREE.CylinderGeometry(cylinderRadius, cylinderRadius, cylinderHeight, 24);
                const bodyMat = new THREE.MeshStandardMaterial({ color: teamColor, metalness: 0.3, roughness: 0.5 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.castShadow = true;
                body.position.y = cylinderHeight / 2;
                playerGroup.add(body);

                const gunGeo = new THREE.BoxGeometry(0.3, 0.3, 1.5);
                const gunMat = new THREE.MeshStandardMaterial({ color: 0x404040, metalness: 0.7, roughness: 0.3 });
                const gun = new THREE.Mesh(gunGeo, gunMat);
                gun.castShadow = true;
                gun.position.set(0, cylinderHeight - 0.5, -0.5);
                playerGroup.add(gun);
                playerGroup.userData.gun = gun;
                playerGroup.userData.team = team; // Store team on the model group

                const flashMaterial = new THREE.MeshBasicMaterial({ color: 0xfff5a1, transparent: true, opacity: 0 });
                const flashGeometry = new THREE.PlaneGeometry(0.5, 0.5);
                const muzzleFlash = new THREE.Mesh(flashGeometry, flashMaterial);
                muzzleFlash.position.set(0, 0, -0.75);
                gun.add(muzzleFlash);
                playerGroup.userData.muzzleFlash = muzzleFlash;

                if (isLocalPlayer) {
                    playerGroup.visible = false;
                }
                return playerGroup;
            }

            createPistol() {
                const viewModel = new THREE.Group();
                const material = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.4 });
                const bodyGeom = new THREE.BoxGeometry(0.2, 0.3, 1);
                const body = new THREE.Mesh(bodyGeom, material);
                const barrelGeom = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 16);
                const barrel = new THREE.Mesh(barrelGeom, material);
                barrel.position.set(0, 0.05, -0.9);
                barrel.rotation.x = Math.PI / 2;
                viewModel.add(body, barrel);
                this.setupViewModel(viewModel, new THREE.Vector3(0.3, -0.3, -1.2));
                return {
                    name: 'Pistol', viewModel, maxAmmo: 10, currentAmmo: 10, reloadTime: 1500,
                    fireRate: 250, isReloading: false, recoilAmount: 0, baseRecoil: 0.1, damage: 20,
                    muzzlePoint: this.createMuzzlePoint(barrel, new THREE.Vector3(0, 0.4, 0))
                };
            }

            createShotgun() {
                const viewModel = new THREE.Group();
                const material = new THREE.MeshStandardMaterial({ color: 0x604020, metalness: 0.6, roughness: 0.5 });
                const bodyGeom = new THREE.BoxGeometry(0.3, 0.3, 1.2);
                const body = new THREE.Mesh(bodyGeom, material);
                const barrelGeom = new THREE.CylinderGeometry(0.08, 0.08, 1.0, 16);
                const barrel = new THREE.Mesh(barrelGeom, material);
                barrel.position.set(0, 0, -0.7);
                barrel.rotation.x = Math.PI / 2;
                viewModel.add(body, barrel);
                this.setupViewModel(viewModel, new THREE.Vector3(0.3, -0.3, -1.2));
                return {
                    name: 'Shotgun', viewModel, maxAmmo: 5, currentAmmo: 5, reloadTime: 2500,
                    fireRate: 1000, isReloading: false, recoilAmount: 0, baseRecoil: 0.4, damage: 10,
                    pellets: 8, spread: 0.05,
                    muzzlePoint: this.createMuzzlePoint(barrel, new THREE.Vector3(0, 0.5, 0))
                };
            }

            createSniper() {
                const viewModel = new THREE.Group();
                const material = new THREE.MeshStandardMaterial({ color: 0x2d3436, metalness: 0.7, roughness: 0.3 });
                const bodyGeom = new THREE.BoxGeometry(0.2, 0.25, 1.8);
                const body = new THREE.Mesh(bodyGeom, material);
                const barrelGeom = new THREE.CylinderGeometry(0.04, 0.04, 1.5, 16);
                const barrel = new THREE.Mesh(barrelGeom, material);
                barrel.position.set(0, 0, -1.2);
                barrel.rotation.x = Math.PI / 2;
                viewModel.add(body, barrel);
                this.setupViewModel(viewModel, new THREE.Vector3(0.3, -0.3, -1.2));
                return {
                    name: 'Sniper', viewModel, maxAmmo: 4, currentAmmo: 4, reloadTime: 3000,
                    fireRate: 1500, isReloading: false, recoilAmount: 0, baseRecoil: 0.8, damage: 100,
                    muzzlePoint: this.createMuzzlePoint(barrel, new THREE.Vector3(0, 0.75, 0))
                };
            }
            
            createMuzzlePoint(parent, position) {
                const muzzlePoint = new THREE.Object3D();
                const flashMaterial = new THREE.MeshBasicMaterial({ color: 0xfff5a1, transparent: true, opacity: 0 });
                const flashGeometry = new THREE.PlaneGeometry(0.5, 0.5);
                const muzzleFlash = new THREE.Mesh(flashGeometry, flashMaterial);
                muzzlePoint.add(muzzleFlash);
                parent.add(muzzlePoint);
                muzzlePoint.position.copy(position);
                muzzlePoint.flash = muzzleFlash;
                return muzzlePoint;
            }
            
            setupViewModel(viewModel, position) {
                viewModel.position.copy(position);
                viewModel.basePosition = position.clone();
                viewModel.rotation.set(0, 0, 0);
                viewModel.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = false;
                        child.receiveShadow = false;
                    }
                });
            }

            initRenderer() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.insertBefore(this.renderer.domElement, document.getElementById('info-container'));
            }

            initMinimap() {
                const minimapContainer = document.getElementById('minimapRenderer');
                this.minimapRenderer = new THREE.WebGLRenderer({ antialias: true });
                this.minimapRenderer.setSize(200, 200);
                minimapContainer.appendChild(this.minimapRenderer.domElement);
                const mapSize = Math.max(this.mapGrid.length, this.mapGrid[0].length) * this.tileSize * 0.7;
                this.minimapCamera = new THREE.OrthographicCamera(-mapSize, mapSize, mapSize, -mapSize, 1, 1000);
                this.minimapCamera.up = new THREE.Vector3(0, 0, -1);
                this.minimapCamera.lookAt(new THREE.Vector3(0, -1, 0));
                this.scene.add(this.minimapCamera);
                const playerIndicatorGeometry = new THREE.SphereGeometry(3, 16, 16);
                const playerIndicatorMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                this.playerIndicator = new THREE.Mesh(playerIndicatorGeometry, playerIndicatorMaterial);
                this.scene.add(this.playerIndicator);
            }
            
            initLighting() {
                this.scene.add(new THREE.AmbientLight(0x606060, 1.2));
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
            }

            initPhysics() {
                this.velocity = new THREE.Vector3();
                this.direction = new THREE.Vector3();
                this.isOnGround = false;
                this.playerHeight = 3.0; // Correct eye-level height
                this.jumpForce = 0.35;
                this.gravity = -0.015;
                this.walkSpeed = 0.3;
                this.runSpeed = 0.6;
                this.playerRadius = 1.0; // Tighter radius for collision
            }
            
            initWorld() {
                this.mapGrid = [
                    [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
                    [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2],
                    [2, 0, 1, 0, 2, 2, 2, 0, 2, 2, 2, 2, 0, 0, 2],
                    [2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2],
                    [2, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 2, 0, 0, 2],
                    [2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 2],
                    [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
                    [2, 0, 2, 2, 2, 2, 0, 1, 0, 2, 2, 2, 2, 0, 2],
                    [2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 2],
                    [2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 2, 2, 0, 2],
                    [2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],
                    [2, 0, 0, 2, 2, 2, 2, 0, 2, 0, 2, 2, 2, 0, 2],
                    [2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 2],
                    [2, 0, 1, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 2],
                    [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
                ];
                this.tileSize = 20;
                this.generateWorldFromGrid();
            }

            initControls() {
                this.keys = {};
                this.mouse = { x: this.initialRotation, y: 0 };
                this.isPointerLocked = false;
                
                document.addEventListener('keydown', (e) => { 
                    this.keys[e.code] = true; 
                    if (e.code === 'KeyR') this.reload();
                    if (e.code === 'Escape') { // Toggle pointer lock on Esc
                        if (document.pointerLockElement === this.renderer.domElement) {
                            document.exitPointerLock();
                        }
                    }
                });
                document.addEventListener('keyup', (e) => { this.keys[e.code] = false; });
                
                document.addEventListener('mousedown', (e) => {
                    if (!this.isPointerLocked && this.isGameStarted) { // Only lock if game has started
                        this.requestPointerLock();
                    } else if (this.isPointerLocked) {
                        if (e.button === 0) this.shoot();
                        else if (e.button === 2) this.toggleZoom();
                    }
                });

                this.renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
                
                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                     if(this.isGameStarted) { // Only show pause menu if game is running
                        document.getElementById('pause-menu').style.display = this.isPointerLocked ? 'none' : 'block';
                        document.getElementById('blocker').style.display = this.isPointerLocked ? 'none' : 'flex';
                     } else { // Keep lobby visible if pointer lock lost before game start
                         document.getElementById('pause-menu').style.display = 'none';
                         document.getElementById('blocker').style.display = 'flex';
                     }
                    document.getElementById('lobby-ui').style.display = 'none'; // Always hide main lobby
                    document.getElementById('match-lobby-ui').style.display = 'none'; // Always hide match lobby
                    
                    if (!this.isPointerLocked && this.isZoomed) this.toggleZoom();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        const sensitivity = 0.002;
                        this.mouse.x -= e.movementX * sensitivity;
                        this.mouse.y -= e.movementY * sensitivity; 
                        this.mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.mouse.y));
                    }
                });

                document.addEventListener('wheel', (e) => {
                    if (!this.isPointerLocked) return;
                    if (this.isZoomed) this.toggleZoom();
                    const currentWeapon = this.weapons[this.currentWeaponIndex];
                    if (currentWeapon.isReloading) return;
                    currentWeapon.viewModel.visible = false;
                    const direction = e.deltaY > 0 ? 1 : -1;
                    this.currentWeaponIndex = (this.currentWeaponIndex + direction + this.weapons.length) % this.weapons.length;
                    this.weapons[this.currentWeaponIndex].viewModel.visible = true;
                    this.updateCrosshair();
                    this.updateAmmoUI();
                });
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            requestPointerLock() {
                this.renderer.domElement.requestPointerLock();
            }

            // --- CORE GAME LOOP AND UPDATES ---
            
            animate() {
                this.animationFrameId = requestAnimationFrame(() => this.animate());
                
                if (!this.clock) this.clock = new THREE.Clock();
                const delta = this.clock.getDelta();
                const elapsedTime = this.clock.getElapsedTime();

                this.updateCameraRotation();
                if (this.isPointerLocked) {
                    this.updatePlayerMovement(delta);
                }
                this.updateViewModel(elapsedTime, delta);
                this.updateEffects();
                this.updateMinimap();

                if (!this.isLocalMode) {
                    this.updateRemotePlayers(delta);
                    const time = performance.now();
                    if (time - this.lastUpdateTime > this.updateInterval) {
                        this.sendPlayerStateToServer();
                        this.lastUpdateTime = time;
                    }
                }

                this.renderer.render(this.scene, this.camera);
            }

            updatePlayerMovement(delta) {
                const currentSpeed = (this.keys['ShiftLeft'] || this.keys['ShiftRight']) ? this.runSpeed : this.walkSpeed;
                
                this.direction.set(0, 0, 0);
                if (this.keys['KeyW']) this.direction.z = 1;
                if (this.keys['KeyS']) this.direction.z = -1;
                if (this.keys['KeyA']) this.direction.x = 1;
                if (this.keys['KeyD']) this.direction.x = -1;

                this.velocity.y += this.gravity;

                if (this.keys['Space'] && this.isOnGround) {
                    this.velocity.y = this.jumpForce;
                    this.isOnGround = false;
                }

                if (this.direction.lengthSq() > 0) {
                    this.direction.normalize();
                    const cameraDirection = new THREE.Vector3();
                    this.camera.getWorldDirection(cameraDirection);
                    cameraDirection.y = 0;
                    cameraDirection.normalize();
                    const right = new THREE.Vector3().crossVectors(this.camera.up, cameraDirection).normalize();
                    const moveVector = new THREE.Vector3()
                        .addScaledVector(cameraDirection, this.direction.z) 
                        .addScaledVector(right, this.direction.x)
                        .normalize()
                        .multiplyScalar(currentSpeed);
                    
                    this.velocity.x = moveVector.x;
                    this.velocity.z = moveVector.z;
                } else {
                    this.velocity.x *= 0.9;
                    this.velocity.z *= 0.9;
                }

                const deltaPosition = this.velocity.clone().multiplyScalar(delta * 60);
                this.handleCollisions(deltaPosition);
                this.camera.position.add(deltaPosition);

                if (this.camera.position.y < this.playerHeight) {
                    this.camera.position.y = this.playerHeight;
                    this.velocity.y = 0;
                    this.isOnGround = true;
                }
                
                // Sync the invisible model with the camera for multiplayer
                this.playerModel.position.copy(this.camera.position);
                this.playerModel.position.y -= this.playerHeight; // Adjust for model height
                this.playerModel.quaternion.setFromEuler(new THREE.Euler(0, this.camera.rotation.y, 0));
                this.playerModel.userData.gun.rotation.x = this.camera.rotation.x;

            }

            updateCameraRotation() {
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.mouse.x;
                this.camera.rotation.x = this.mouse.y;
            }

            updateViewModel(elapsedTime, delta) {
                const weapon = this.weapons[this.currentWeaponIndex];
                const viewModel = weapon.viewModel;
                viewModel.position.z = viewModel.basePosition.z + weapon.recoilAmount;
                weapon.recoilAmount *= 0.8;
                viewModel.position.y = viewModel.basePosition.y;

                if (viewModel.reloadFlipAmount > 0) {
                    const flipSpeed = (Math.PI * 2) / (weapon.reloadTime / 1000 * 0.5);
                    const deltaFlip = flipSpeed * delta;
                    viewModel.rotation.x += deltaFlip;
                    viewModel.reloadFlipAmount -= deltaFlip;
                } else {
                    viewModel.rotation.x = 0; 
                }
            }

            updateEffects() {
                const now = Date.now();
                this.bulletTrails = this.bulletTrails.filter(trail => {
                    const age = now - trail.createdAt;
                    if (age > 200) { this.scene.remove(trail.line); return false; }
                    trail.line.material.opacity = 1.0 * (1 - age / 200);
                    return true;
                });
                this.bulletDecals = this.bulletDecals.filter(decal => {
                    const age = now - decal.createdAt;
                    if (age > 5000) { this.scene.remove(decal.mesh); return false; }
                    decal.mesh.material.opacity = 0.8 * (1 - age / 5000);
                    return true;
                });
            }

            updateMinimap() {
                this.minimapCamera.position.set(this.camera.position.x, 150, this.camera.position.z);
                this.playerIndicator.position.copy(this.camera.position);
                this.playerIndicator.position.y = 50; // Raised indicator
                this.minimapRenderer.render(this.scene, this.minimapCamera);
            }

            // --- ACTIONS (SHOOTING, RELOADING, ETC.) ---

            shoot() {
                const weapon = this.weapons[this.currentWeaponIndex];
                const now = performance.now();
                if (weapon.isReloading || weapon.currentAmmo <= 0 || now - this.lastShotTime < weapon.fireRate) return;
                
                if (this.isZoomed && weapon.name !== 'Sniper') this.toggleZoom();

                this.lastShotTime = now;
                weapon.currentAmmo--;
                this.updateAmmoUI();
                weapon.recoilAmount = weapon.baseRecoil;
                weapon.muzzlePoint.flash.material.opacity = 1;
                setTimeout(() => { weapon.muzzlePoint.flash.material.opacity = 0; }, 60);

                if (weapon.name === 'Shotgun') {
                    for (let i = 0; i < weapon.pellets; i++) this.fireBullet(weapon.spread);
                } else {
                    this.fireBullet(0);
                }
                if (weapon.currentAmmo === 0) this.reload();
            }
            
            async fireBullet(spread) {
                const weapon = this.weapons[this.currentWeaponIndex];
                const spreadDirection = new THREE.Vector2((Math.random() - 0.5) * spread, (Math.random() - 0.5) * spread);
                this.raycaster.setFromCamera(spreadDirection, this.camera);
                
                const shootableMeshes = this.shootableObjects.concat(Object.values(this.playerMeshes).map(p => p.mesh));
                const intersects = this.raycaster.intersectObjects(shootableMeshes, true);

                let endPoint;
                let hitNormal;
                let hit = false;
                if (intersects.length > 0) {
                    const intersection = intersects[0];
                    endPoint = intersection.point;
                    hit = true;
                    if (intersection.face) {
                         hitNormal = intersection.face.normal;
                         this.createBulletDecal(endPoint, hitNormal);
                    }

                    let hitObject = intersection.object;
                    while(hitObject.parent && !hitObject.userData.playerId) {
                        hitObject = hitObject.parent;
                    }
                    if (hitObject.userData.playerId && !this.isLocalMode) {
                        const targetId = hitObject.userData.playerId;
                        const targetData = this.playerDataCache[targetId]; // Get team from cache
                        
                        if(targetData && targetData.team !== this.team) { // Check for friendly fire
                            const targetRef = doc(this.db, `/artifacts/${this.appId}/public/data/lobbies/${this.currentLobbyId}/players`, targetId);
                            const targetDoc = await getDoc(targetRef); // Get current health
                            if(targetDoc.exists()) {
                                const currentTargetData = targetDoc.data();
                                const newHealth = Math.max(0, currentTargetData.health - weapon.damage);
                                await updateDoc(targetRef, { health: newHealth });
                            }
                        }
                    }

                } else {
                    endPoint = new THREE.Vector3();
                    this.raycaster.ray.at(1000, endPoint);
                }

                this.createBulletTrail(endPoint);

                if(!this.isLocalMode) {
                    const startPoint = new THREE.Vector3();
                    weapon.muzzlePoint.getWorldPosition(startPoint);
                    const eventsCollectionPath = `/artifacts/${this.appId}/public/data/lobbies/${this.currentLobbyId}/events`;
                    await addDoc(collection(this.db, eventsCollectionPath), {
                        type: 'SHOOT',
                        shooterId: this.userId,
                        startPoint: {x: startPoint.x, y: startPoint.y, z: startPoint.z},
                        endPoint: {x: endPoint.x, y: endPoint.y, z: endPoint.z},
                        hit: hit,
                        hitNormal: hitNormal ? {x: hitNormal.x, y: hitNormal.y, z: hitNormal.z} : null,
                        timestamp: Date.now()
                    });
                }
            }
            
            createBulletTrail(endPoint, startPoint = null) {
                if (!startPoint) {
                    const weapon = this.weapons[this.currentWeaponIndex];
                    startPoint = new THREE.Vector3();
                    weapon.muzzlePoint.getWorldPosition(startPoint);
                }
                const points = [startPoint, endPoint];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 1.0 });
                const trail = new THREE.Line(geometry, material);
                this.scene.add(trail);
                this.bulletTrails.push({ line: trail, createdAt: Date.now() });
            }

            createBulletDecal(position, normal) {
                const decalMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.8, depthTest: true, depthWrite: false });
                const decalGeometry = new THREE.PlaneGeometry(0.2, 0.2);
                const decal = new THREE.Mesh(decalGeometry, decalMaterial);
                decal.position.copy(position);
                decal.lookAt(position.clone().add(normal));
                decal.position.add(normal.multiplyScalar(0.01)); // Prevent z-fighting
                this.scene.add(decal);
                this.bulletDecals.push({ mesh: decal, createdAt: Date.now() });
            }

            reload() {
                const weapon = this.weapons[this.currentWeaponIndex];
                if (weapon.isReloading || weapon.currentAmmo === weapon.maxAmmo) return;
                if (this.isZoomed) this.toggleZoom();
                weapon.isReloading = true;
                weapon.viewModel.reloadFlipAmount = Math.PI * 2;
                this.updateAmmoUI();
                setTimeout(() => {
                    weapon.currentAmmo = weapon.maxAmmo;
                    weapon.isReloading = false;
                    this.updateAmmoUI();
                }, weapon.reloadTime);
            }

            toggleZoom() {
                const weapon = this.weapons[this.currentWeaponIndex];
                if (weapon.name !== 'Sniper' || weapon.isReloading) return;
                this.isZoomed = !this.isZoomed;
                this.camera.fov = this.isZoomed ? this.zoomFov : this.defaultFov;
                this.camera.updateProjectionMatrix();
                document.getElementById('sniperScope').style.display = this.isZoomed ? 'block' : 'none';
                document.getElementById('scopeLines').style.display = this.isZoomed ? 'block' : 'none';
                document.getElementById('crosshair').style.display = this.isZoomed ? 'none' : 'block';
                weapon.viewModel.visible = !this.isZoomed;
            }

            handleDeath() {
                console.log("Player died and respawned.");
                const respawnPosition = this.getStartPosition(this.team); // Use team for respawn
                this.camera.position.set(respawnPosition.x, this.playerHeight, respawnPosition.z);
                this.velocity.set(0, 0, 0);
                this.health = 100;
                this.updateHealthUI();
                if (this.playerRef) {
                    updateDoc(this.playerRef, {
                        health: 100,
                        x: respawnPosition.x,
                        y: this.camera.position.y, // Send camera y pos
                        z: respawnPosition.z
                    });
                }
            }

            // --- MULTIPLAYER ---

            sendPlayerStateToServer() {
                if (this.playerRef) {
                    updateDoc(this.playerRef, {
                        x: this.camera.position.x, 
                        y: this.camera.position.y, 
                        z: this.camera.position.z,
                        yaw: this.mouse.x,
                        pitch: this.mouse.y
                    });
                }
            }

            listenForPlayers(collectionPath, isMatchLobby) {
                onSnapshot(collection(this.db, collectionPath), (snapshot) => {
                    const players = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    this.playerDataCache = {}; // Clear cache
                    players.forEach(p => this.playerDataCache[p.userId] = { team: p.team }); // Update cache

                    if (isMatchLobby) {
                        const teamAPlayers = players.filter(p => p.team === 'A').sort((a, b) => (a.userId > b.userId ? 1 : -1));
                        const teamBPlayers = players.filter(p => p.team === 'B').sort((a, b) => (a.userId > b.userId ? 1 : -1));
                        
                        const updateSlot = (slotId, player) => {
                            const slot = document.getElementById(slotId);
                            if (player) {
                                slot.innerHTML = `${player.username}: <span class="${player.ready ? 'status-ready' : 'status-not-ready'}">${player.ready ? 'Ready' : 'Not Ready'}</span>`;
                            } else {
                                slot.textContent = `Slot ${parseInt(slotId.split('-')[2]) + 1}: Waiting...`;
                            }
                        };

                        updateSlot('player-slot-0', teamAPlayers[0]);
                        updateSlot('player-slot-1', teamBPlayers[0]);
                        if (this.gameMode === '2v2') {
                            updateSlot('player-slot-2', teamAPlayers[1]);
                            updateSlot('player-slot-3', teamBPlayers[1]);
                        }
                        
                        if (players.length === this.maxPlayers && players.every(p => p.ready)) {
                             this.playerIndex = players.findIndex(p => p.userId === this.userId);
                             this.team = players.find(p => p.userId === this.userId)?.team || 'A'; // Get assigned team
                             this.startGame(this.currentLobbyId, false);
                        }

                    } else { // In-game listener
                        snapshot.docChanges().forEach((change) => {
                            const docId = change.doc.id;
                            const data = change.doc.data();

                            if (docId === this.userId) {
                                if (data.health !== undefined && data.health < this.health) {
                                    this.health = data.health;
                                    if (this.health <= 0) {
                                        this.handleDeath();
                                    } else {
                                        this.updateHealthUI();
                                    }
                                }
                                return;
                            }

                            let player = this.playerMeshes[docId];

                            if (change.type === "added" && !player) {
                                const model = this.createPlayerModel(Math.random() * 0xffffff, false, data.team);
                                model.userData.playerId = docId;
                                const usernameLabel = this.createUsernameLabel(data.username);
                                model.add(usernameLabel);
                                
                                this.playerMeshes[docId] = { 
                                    mesh: model, 
                                    usernameLabel: usernameLabel,
                                    targetPosition: new THREE.Vector3(data.x, data.y - this.playerHeight, data.z), // Initial position
                                    targetYaw: data.yaw || 0,
                                    targetPitch: data.pitch || 0
                                };
                                this.scene.add(model);
                                this.shootableObjects.push(model); 
                            } else if (change.type === "removed" && player) {
                                this.scene.remove(player.mesh);
                                const index = this.shootableObjects.indexOf(player.mesh);
                                if(index > -1) this.shootableObjects.splice(index, 1);
                                delete this.playerMeshes[docId];
                                return;
                            }
                            
                            player = this.playerMeshes[docId];
                            if (player && data) {
                                // Set target position directly - interpolation happens in updateRemotePlayers
                                player.targetPosition.set(data.x, data.y - this.playerHeight, data.z); 
                                if(data.yaw !== undefined) player.targetYaw = data.yaw;
                                if(data.pitch !== undefined) player.targetPitch = data.pitch;
                                player.mesh.visible = data.health > 0;
                            }
                        });
                    }
                });
            }
            
            listenForGameEvents() {
                 const eventsCollectionPath = `/artifacts/${this.appId}/public/data/lobbies/${this.currentLobbyId}/events`;
                 onSnapshot(collection(this.db, eventsCollectionPath), (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === "added") {
                            const event = change.doc.data();
                            if (event.shooterId !== this.userId && event.type === 'SHOOT') {
                                const startPoint = new THREE.Vector3(event.startPoint.x, event.startPoint.y, event.startPoint.z);
                                const endPoint = new THREE.Vector3(event.endPoint.x, event.endPoint.y, event.endPoint.z);
                                this.createBulletTrail(endPoint, startPoint); 
                                if (event.hit && event.hitNormal) {
                                    const hitNormal = new THREE.Vector3(event.hitNormal.x, event.hitNormal.y, event.hitNormal.z);
                                    this.createBulletDecal(endPoint, hitNormal);
                                }
                                const shooter = this.playerMeshes[event.shooterId];
                                if(shooter && shooter.mesh.userData.muzzleFlash){
                                    shooter.mesh.userData.muzzleFlash.material.opacity = 1;
                                    setTimeout(() => { shooter.mesh.userData.muzzleFlash.material.opacity = 0; }, 60);
                                }
                            }
                        }
                    });
                });
            }

            updateRemotePlayers(delta) {
                const factor = delta * 15;
                for (const id in this.playerMeshes) {
                    const player = this.playerMeshes[id];
                    player.mesh.position.lerp(player.targetPosition, factor);
                    
                    const targetQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), player.targetYaw);
                    player.mesh.quaternion.slerp(targetQuat, factor);
                    
                    player.mesh.userData.gun.rotation.x += (player.targetPitch - player.mesh.userData.gun.rotation.x) * factor;

                    if (player.usernameLabel) {
                        player.usernameLabel.quaternion.copy(this.camera.quaternion);
                    }
                }
            }

            // --- UTILITIES AND HELPERS ---

            handleCollisions(deltaPosition) {
                const playerSphere = new THREE.Sphere(this.camera.position, this.playerRadius);
                for (const obj of this.collidableObjects) {
                    const nextPlayerSphere = new THREE.Sphere(playerSphere.center.clone().add(deltaPosition), playerSphere.radius);
                    if (obj.type === 'box' && nextPlayerSphere.intersectsBox(obj.bounds)) {
                        const closestPoint = new THREE.Vector3().copy(nextPlayerSphere.center).clamp(obj.bounds.min, obj.bounds.max);
                        const penetrationVector = new THREE.Vector3().subVectors(nextPlayerSphere.center, closestPoint).normalize();
                        const dot = deltaPosition.dot(penetrationVector);
                        if (dot < 0) deltaPosition.sub(penetrationVector.multiplyScalar(dot));
                    } else if (obj.type === 'sphere' && nextPlayerSphere.intersectsSphere(obj.bounds)) {
                        const penetrationVector = new THREE.Vector3().subVectors(nextPlayerSphere.center, obj.bounds.center).normalize();
                        const dot = deltaPosition.dot(penetrationVector);
                        if (dot < 0) deltaPosition.sub(penetrationVector.multiplyScalar(dot));
                    }
                }
            }

            generateWorldFromGrid() {
                const wallHeight = this.tileSize;
                const gridWidth = this.mapGrid[0].length * this.tileSize;
                const gridDepth = this.mapGrid.length * this.tileSize;
                const offsetX = -gridWidth / 2;
                const offsetZ = -gridDepth / 2;

                const groundGeometry = new THREE.PlaneGeometry(gridWidth, gridDepth);
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x66aa66 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
                this.shootableObjects.push(ground);

                this.mapGrid.forEach((row, z) => {
                    row.forEach((tileType, x) => {
                        const worldX = offsetX + x * this.tileSize + this.tileSize / 2;
                        const worldZ = offsetZ + z * this.tileSize + this.tileSize / 2;

                        switch (tileType) {
                            case 1:
                                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, 8), new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
                                trunk.position.set(worldX, 4, worldZ);
                                trunk.castShadow = true;
                                this.scene.add(trunk);
                                const leaves = new THREE.Mesh(new THREE.SphereGeometry(4, 8, 8), new THREE.MeshLambertMaterial({ color: 0x228B22 }));
                                leaves.position.set(worldX, 8 + 2, worldZ);
                                leaves.castShadow = true;
                                this.scene.add(leaves);
                                this.collidableObjects.push({ mesh: trunk, type: 'sphere', bounds: new THREE.Sphere(trunk.position, 1.5) });
                                this.shootableObjects.push(trunk, leaves);
                                break;
                            case 2:
                                const wall = new THREE.Mesh(new THREE.BoxGeometry(this.tileSize, wallHeight, this.tileSize), new THREE.MeshLambertMaterial({ color: new THREE.Color(0.5, 0.5, 0.5) }));
                                wall.position.set(worldX, wallHeight / 2, worldZ);
                                wall.castShadow = true;
                                wall.receiveShadow = true;
                                this.scene.add(wall);
                                const box = new THREE.Box3().setFromObject(wall);
                                this.collidableObjects.push({ mesh: wall, type: 'box', bounds: box });
                                this.shootableObjects.push(wall);
                                break;
                        }
                    });
                });
            }

            getStartPosition(team = 'A') {
                const gridWidth = this.mapGrid[0].length;
                const gridDepth = this.mapGrid.length;
                const offsetX = -gridWidth * this.tileSize / 2;
                const offsetZ = -gridDepth * this.tileSize / 2;
                
                // Define spawn zones (areas within the grid)
                 const spawnZones = {
                    'A': [{ x: 1, z: 1 }, { x: 2, z: 1 }, { x: 1, z: 2 }], // Top-left area
                    'B': [{ x: gridWidth - 2, z: gridDepth - 2 }, { x: gridWidth - 3, z: gridDepth - 2 }, { x: gridWidth - 2, z: gridDepth - 3 }] // Bottom-right area
                };

                const zone = spawnZones[team] || spawnZones['A'];
                const spawn = zone[Math.floor(Math.random() * zone.length)]; // Pick random point in zone

                return {
                    x: offsetX + spawn.x * this.tileSize + this.tileSize / 2,
                    z: offsetZ + spawn.z * this.tileSize + this.tileSize / 2
                };
            }

            createUsernameLabel(text) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                context.font = 'Bold 48px Inter';
                const metrics = context.measureText(text);
                const textWidth = metrics.width;
                canvas.width = textWidth + 20; // Add some padding
                canvas.height = 64; 
                context.font = 'Bold 48px Inter';
                context.fillStyle = 'rgba(0, 0, 0, 0.5)'; // Semi-transparent black background
                context.fillRect(0, 0, canvas.width, canvas.height);
                context.fillStyle = 'rgba(255, 255, 255, 1.0)';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width / 2, canvas.height / 2);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
                const sprite = new THREE.Sprite(spriteMaterial);
                
                sprite.scale.set(canvas.width / 64, canvas.height / 64, 1.0);
                sprite.position.y = 5; // Position above the player's head
                return sprite;
            }

            updateCrosshair() {
                const weapon = this.weapons[this.currentWeaponIndex];
                const crosshair = document.getElementById('crosshair');
                crosshair.className = '';
                switch(weapon.name) {
                    case 'Shotgun': crosshair.classList.add('shotgun-crosshair'); break;
                    default: crosshair.classList.add('default-crosshair'); break;
                }
            }

            updateAmmoUI() {
                const weapon = this.weapons[this.currentWeaponIndex];
                const ammoElem = document.getElementById('ammoInfo');
                if (weapon.isReloading) {
                    ammoElem.innerHTML = `${weapon.name}<br>Reloading...`;
                } else {
                    ammoElem.innerHTML = `${weapon.name}<br>${weapon.currentAmmo} / ${weapon.maxAmmo}`;
                }
            }

            updateHealthUI() {
                const healthBar = document.getElementById('healthBar');
                const healthText = document.getElementById('healthText');
                const healthPercentage = (this.health / 100) * 100;
                healthBar.style.width = `${healthPercentage}%`;
                healthText.textContent = `${this.health} / 100`;

                if (healthPercentage > 50) {
                    healthBar.style.backgroundColor = '#4caf50'; // Green
                } else if (healthPercentage > 25) {
                    healthBar.style.backgroundColor = '#ffc107'; // Yellow
                } else {
                    healthBar.style.backgroundColor = '#f44336'; // Red
                }
            }
             
             clearScene() {
                 if (!this.scene) return;
                // Remove dynamic objects like players, bullets, decals
                Object.values(this.playerMeshes).forEach(p => this.scene.remove(p.mesh));
                this.playerMeshes = {};
                this.bulletTrails.forEach(t => this.scene.remove(t.line));
                this.bulletTrails = [];
                this.bulletDecals.forEach(d => this.scene.remove(d.mesh));
                this.bulletDecals = [];
                 // Stop animation loop
                 if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                 }
                // Optionally remove weapons from camera etc.
                this.weapons.forEach(w => this.camera.remove(w.viewModel));
                this.weapons = [];

                 // Remove lights and world geometry if necessary
                // This might be excessive if you plan to reuse the scene structure
             }

             showError(message) {
                 const errorElem = document.getElementById('error-message');
                 errorElem.textContent = message;
                 errorElem.style.color = '#ef5350'; // Red
                 setTimeout(() => {
                     if(errorElem.textContent === message) {
                         errorElem.textContent = ''; // Clear after a few seconds
                     }
                 }, 3000);
             }
        }

        new MultiplayerFPSGame();
    </script>
</body>
</html>

