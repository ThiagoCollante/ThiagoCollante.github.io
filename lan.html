<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LAN Top-Down Vector Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #111827; /* bg-gray-900 */
        }
        canvas {
            background-color: #374151; /* bg-gray-700 */
            cursor: crosshair;
            display: block;
        }
        .glassmorphism {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body class="text-white">

    <!-- Connection UI -->
    <div id="connection-ui" class="absolute inset-0 z-10 flex flex-col items-center justify-center p-4">
        <div class="w-full max-w-2xl p-8 space-y-6 rounded-lg shadow-xl glassmorphism">
            <h1 class="text-3xl font-bold text-center">LAN Vector Controller</h1>
            <p class="text-center text-gray-300">Play with friends on the same network. No server required!</p>
            
            <!-- Host/Join Tabs -->
            <div class="flex border-b border-gray-600">
                <button id="host-tab-btn" class="flex-1 py-2 font-semibold text-center text-white border-b-2 border-indigo-500">Host</button>
                <button id="join-tab-btn" class="flex-1 py-2 font-semibold text-center text-gray-400">Join</button>
            </div>

            <!-- Host Section -->
            <div id="host-section" class="space-y-4">
                <div>
                    <h2 class="text-xl font-semibold">1. Start a New Game</h2>
                    <p class="text-sm text-gray-400">Click the button to generate a connection code for others to join.</p>
                    <button id="host-btn" class="w-full px-4 py-2 mt-2 font-bold text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 transition">Host Game</button>
                </div>
                <div>
                    <h2 class="text-xl font-semibold">2. Share This Code</h2>
                     <p class="text-sm text-gray-400">Send this code to your friends so they can join your game.</p>
                    <textarea id="offer-sdp" readonly class="w-full h-24 p-2 mt-2 bg-gray-800 border border-gray-600 rounded-md resize-none focus:outline-none focus:ring-2 focus:ring-indigo-500"></textarea>
                </div>
                <div>
                    <h2 class="text-xl font-semibold">3. Paste Their Answer Code</h2>
                    <p class="text-sm text-gray-400">Paste the code they send back to you here to complete the connection.</p>
                    <textarea id="answer-sdp-host" class="w-full h-24 p-2 mt-2 bg-gray-800 border border-gray-600 rounded-md resize-none focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Paste joiner's code here..."></textarea>
                    <button id="connect-btn" class="w-full px-4 py-2 mt-2 font-bold text-white bg-green-600 rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 transition">Connect</button>
                </div>
            </div>

            <!-- Join Section (Initially hidden) -->
            <div id="join-section" class="hidden space-y-4">
                 <div>
                    <h2 class="text-xl font-semibold">1. Paste Host's Code</h2>
                    <p class="text-sm text-gray-400">Get the code from the host and paste it below.</p>
                    <textarea id="offer-sdp-join" class="w-full h-24 p-2 mt-2 bg-gray-800 border border-gray-600 rounded-md resize-none focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Paste host's code here..."></textarea>
                    <button id="join-btn" class="w-full px-4 py-2 mt-2 font-bold text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 transition">Create Join Code</button>
                </div>
                 <div>
                    <h2 class="text-xl font-semibold">2. Share This Code Back</h2>
                     <p class="text-sm text-gray-400">Send this new code back to the host to finalize the connection.</p>
                    <textarea id="answer-sdp-join" readonly class="w-full h-24 p-2 mt-2 bg-gray-800 border border-gray-600 rounded-md resize-none focus:outline-none focus:ring-2 focus:ring-indigo-500"></textarea>
                </div>
            </div>
             <div id="status" class="text-center text-yellow-400 h-4"></div>
        </div>
    </div>

    <!-- Game Canvas -->
    <canvas id="game-canvas" class="hidden"></canvas>
    
    <script>
        // --- DOM Elements ---
        const connectionUI = document.getElementById('connection-ui');
        const gameCanvas = document.getElementById('game-canvas');
        const hostBtn = document.getElementById('host-btn');
        const connectBtn = document.getElementById('connect-btn');
        const joinBtn = document.getElementById('join-btn');
        const offerSdpText = document.getElementById('offer-sdp');
        const answerSdpHostText = document.getElementById('answer-sdp-host');
        const offerSdpJoinText = document.getElementById('offer-sdp-join');
        const answerSdpJoinText = document.getElementById('answer-sdp-join');
        const statusText = document.getElementById('status');
        
        const hostTabBtn = document.getElementById('host-tab-btn');
        const joinTabBtn = document.getElementById('join-tab-btn');
        const hostSection = document.getElementById('host-section');
        const joinSection = document.getElementById('join-section');

        // --- WebRTC & Game State ---
        let peerConnection;
        let dataChannel;
        const players = {};
        let localPlayerId = 'player_' + Math.random().toString(36).substr(2, 9);
        let gameStarted = false;

        const keys = { w: false, a: false, s: false, d: false };
        const mouse = { x: 0, y: 0 };

        const ctx = gameCanvas.getContext('2d');

        // --- Player Class ---
        class Player {
            constructor(id) {
                this.id = id;
                this.x = Math.random() * window.innerWidth;
                this.y = Math.random() * window.innerHeight;
                this.vx = 0;
                this.vy = 0;
                this.angle = 0;
                this.speed = 4;
                this.size = 15;
                this.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
            }

            update() {
                // Movement logic for the local player
                if (this.id === localPlayerId) {
                    this.vx = 0;
                    this.vy = 0;
                    if (keys.w) this.vy = -this.speed;
                    if (keys.s) this.vy = this.speed;
                    if (keys.a) this.vx = -this.speed;
                    if (keys.d) this.vx = this.speed;

                    this.x += this.vx;
                    this.y += this.vy;

                    // Update angle based on mouse position
                    const dx = mouse.x - this.x;
                    const dy = mouse.y - this.y;
                    this.angle = Math.atan2(dy, dx);
                    
                    // Boundary checks
                    if (this.x < this.size) this.x = this.size;
                    if (this.x > window.innerWidth - this.size) this.x = window.innerWidth - this.size;
                    if (this.y < this.size) this.y = this.size;
                    if (this.y > window.innerHeight - this.size) this.y = window.innerHeight - this.size;
                }
            }

            draw(context) {
                context.save();
                context.translate(this.x, this.y);
                context.rotate(this.angle);

                // Draw player triangle
                context.fillStyle = this.color;
                context.beginPath();
                context.moveTo(this.size, 0);
                context.lineTo(-this.size / 2, -this.size / 2);
                context.lineTo(-this.size / 2, this.size / 2);
                context.closePath();
                context.fill();
                
                context.restore();

                // Draw player ID
                context.fillStyle = 'white';
                context.font = '12px Inter';
                context.textAlign = 'center';
                context.fillText(this.id, this.x, this.y - this.size - 5);
            }
        }
        
        // --- UI Logic ---
        hostTabBtn.addEventListener('click', () => {
            hostSection.classList.remove('hidden');
            joinSection.classList.add('hidden');
            hostTabBtn.classList.add('border-indigo-500', 'text-white');
            hostTabBtn.classList.remove('text-gray-400');
            joinTabBtn.classList.remove('border-indigo-500', 'text-white');
            joinTabBtn.classList.add('text-gray-400');
        });

        joinTabBtn.addEventListener('click', () => {
            joinSection.classList.remove('hidden');
            hostSection.classList.add('hidden');
            joinTabBtn.classList.add('border-indigo-500', 'text-white');
            joinTabBtn.classList.remove('text-gray-400');
            hostTabBtn.classList.remove('border-indigo-500', 'text-white');
            hostTabBtn.classList.add('text-gray-400');
        });


        // --- WebRTC Functions ---
        const servers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' }, // Public STUN server
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        const createPeerConnection = () => {
            const pc = new RTCPeerConnection(servers);
            pc.onicecandidate = event => {
                if (event.candidate) {
                    // This fires automatically, we just need to wait for it to finish
                    // then the full SDP will be available.
                } else {
                    // ICE gathering is complete
                    if (pc.localDescription.type === 'offer') {
                        offerSdpText.value = JSON.stringify(pc.localDescription);
                    } else if (pc.localDescription.type === 'answer') {
                        answerSdpJoinText.value = JSON.stringify(pc.localDescription);
                    }
                }
            };

            pc.onconnectionstatechange = () => {
                 statusText.textContent = `Connection state: ${pc.connectionState}`;
                 if(pc.connectionState === 'connected') {
                     startGame();
                 }
            };

            return pc;
        };
        
        const setupDataChannel = (pc) => {
            pc.ondatachannel = (event) => {
                dataChannel = event.channel;
                configureDataChannel();
            };
        };

        const configureDataChannel = () => {
            dataChannel.onopen = () => {
                console.log("Data channel is open");
                startGame();
            };
            dataChannel.onclose = () => {
                console.log("Data channel is closed");
                alert("Player disconnected. Please refresh to start a new game.");
                location.reload();
            };
            dataChannel.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'playerUpdate' && data.id !== localPlayerId) {
                    if (!players[data.id]) {
                        players[data.id] = new Player(data.id);
                        players[data.id].color = data.color; // Sync color
                    }
                    players[data.id].x = data.x;
                    players[data.id].y = data.y;
                    players[data.id].angle = data.angle;
                }
            };
        };

        hostBtn.addEventListener('click', async () => {
            peerConnection = createPeerConnection();
            setupDataChannel(peerConnection);
            dataChannel = peerConnection.createDataChannel("gameData");
            configureDataChannel();

            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            statusText.textContent = 'Offer created. Waiting for ICE candidates...';
        });

        connectBtn.addEventListener('click', async () => {
            if (!answerSdpHostText.value) {
                statusText.textContent = 'Please paste the joiner\'s code first.';
                return;
            }
            try {
                const answer = JSON.parse(answerSdpHostText.value);
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                statusText.textContent = 'Answer set. Connecting...';
            } catch (e) {
                statusText.textContent = 'Invalid answer code.';
                console.error(e);
            }
        });
        
        joinBtn.addEventListener('click', async () => {
             if (!offerSdpJoinText.value) {
                statusText.textContent = 'Please paste the host\'s code first.';
                return;
            }
            peerConnection = createPeerConnection();
            setupDataChannel(peerConnection);

            try {
                const offer = JSON.parse(offerSdpJoinText.value);
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                statusText.textContent = 'Answer created. Waiting for ICE candidates...';
            } catch(e) {
                statusText.textContent = 'Invalid host code.';
                console.error(e);
            }
        });

        // --- Game Logic ---
        function startGame() {
            if (gameStarted) return;
            gameStarted = true;
            connectionUI.style.display = 'none';
            gameCanvas.style.display = 'block';
            
            // Initialize local player
            players[localPlayerId] = new Player(localPlayerId);

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            document.addEventListener('keydown', e => keys[e.key] = true);
            document.addEventListener('keyup', e => keys[e.key] = false);
            document.addEventListener('mousemove', e => {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
            });

            gameLoop();
        }

        function resizeCanvas() {
            gameCanvas.width = window.innerWidth;
            gameCanvas.height = window.innerHeight;
        }

        function sendPlayerUpdate() {
            if (dataChannel && dataChannel.readyState === 'open') {
                const p = players[localPlayerId];
                const data = {
                    type: 'playerUpdate',
                    id: p.id,
                    x: p.x,
                    y: p.y,
                    angle: p.angle,
                    color: p.color
                };
                dataChannel.send(JSON.stringify(data));
            }
        }

        function gameLoop() {
            // Update local player
            players[localPlayerId].update();

            // Send local player data to peer
            sendPlayerUpdate();

            // Draw everything
            ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
            for (const id in players) {
                players[id].draw(ctx);
            }

            requestAnimationFrame(gameLoop);
        }

    </script>
</body>
</html>
