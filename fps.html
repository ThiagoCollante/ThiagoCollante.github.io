<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Multiplayer Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            color: white;
            background-color: #111;
        }
        canvas {
            display: block;
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #lobby-ui {
            width: 90%;
            max-width: 450px;
            padding: 25px;
            background-color: #222;
            border-radius: 12px;
            text-align: center;
            border: 1px solid #444;
        }
        .lobby-input {
            width: 100%;
            box-sizing: border-box;
            padding: 10px;
            margin: 10px 0;
            border-radius: 6px;
            border: 1px solid #555;
            background-color: #333;
            color: white;
            text-align: center;
            font-size: 1rem;
        }
        .lobby-button {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            border-radius: 6px;
            border: none;
            background-color: #0074d9;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .lobby-button:hover:not(:disabled) {
            background-color: #0062b3;
        }
         #create-lobby-btn {
            background-color: #2ecc40;
        }
        #create-lobby-btn:hover:not(:disabled) {
            background-color: #27a837;
        }
        .lobby-button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #error-message {
            color: #ef5350; /* Light red */
            margin-top: 10px;
            min-height: 20px;
        }
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            border: 1px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            mix-blend-mode: difference;
            z-index: 100;
        }
        #game-ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }
        .info-box {
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            font-size: 12px;
            pointer-events: all;
        }
        #player-list-container {
             width: 200px;
        }
         #player-list-container h3 {
            margin: 0 0 10px;
            text-align: center;
        }
        #player-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
         #player-list li {
            display: flex;
            align-items: center;
        }
         .player-color-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid white;
        }
        #version-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 10px;
            color: rgba(255,255,255,0.4);
        }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="lobby-ui">
            <h1>3D LAN Game</h1>
            <p>Create a new lobby or enter an ID to join.</p>
            <input type="text" id="join-lobby-input" class="lobby-input" placeholder="Enter Lobby ID" disabled>
            <button id="join-lobby-btn" class="lobby-button" disabled>Join Lobby</button>
            <hr style="margin: 20px 0; border-color: #444;">
            <button id="create-lobby-btn" class="lobby-button" disabled>Create New Lobby</button>
            <p id="error-message">Connecting...</p>
        </div>
    </div>

    <div id="game-ui-container" style="display: none;">
        <div id="info-container" class="info-box">
            Lobby ID: <span id="lobbyId" style="font-weight:bold; color: #ffdc00;">N/A</span>
        </div>
        <div id="player-list-container" class="info-box">
            <h3>Players</h3>
            <ul id="player-list"></ul>
        </div>
    </div>
    
    <div id="version-info" style="display: none;">v3.2.3d.fix</div>
    <div class="crosshair" style="display: none;"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer;
        let db, auth;
        let userId, currentLobbyId, appId;
        let playerRef;
        let unsubscribeFromPlayers = null;
        
        const playerMeshes = {};
        const PLAYER_COLORS = [0xff4136, 0x0074d9, 0x2ecc40, 0xffdc00, 0xf012be, 0xff851b];

        // --- Movement & Physics ---
        const moveState = { forward: false, backward: false, left: false, right: false, jump: false, run: false };
        const playerVelocity = new THREE.Vector3();
        const walkSpeed = 5.0;
        const runSpeed = 8.0;
        const gravity = -30.0;
        const jumpForce = 10.0;
        let canJump = false;
        let lastTime = performance.now();
        let isGameStarted = false;
        
        // --- Update Throttling ---
        const updateInterval = 100; // ms
        let lastUpdateTime = 0;

        async function init() {
            initLobbyUI();
            initEventListeners();
            await initFirebase();
        }

        async function initFirebase() {
             const firebaseConfig = {
                apiKey: "AIzaSyBX7Qk3hB7vNykKt9WyiDNWrqq0eXxpGMA",
                authDomain: "lanhtml-d905d.firebaseapp.com",
                projectId: "lanhtml-d905d",
                storageBucket: "lanhtml-d905d.appspot.com",
                messagingSenderId: "427246041879",
                appId: "1:427246041879:web:b455c681ee7b952edc9552"
            };
            
            appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.projectId;
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            onAuthStateChanged(auth, (user) => {
                const errorMessage = document.getElementById('error-message');
                if (user) {
                    userId = user.uid;
                    document.getElementById('create-lobby-btn').disabled = false;
                    document.getElementById('join-lobby-btn').disabled = false;
                    document.getElementById('join-lobby-input').disabled = false;
                    errorMessage.textContent = 'Connected. Ready to join.';
                } else {
                    errorMessage.textContent = "Authentication failed. You are not signed in.";
                }
            });

            try {
                await signInAnonymously(auth);
            } catch (error) {
                console.error("Firebase authentication failed:", error);
                document.getElementById('error-message').textContent = "Authentication failed. Please refresh.";
            }
        }

        function initLobbyUI() {
            const createBtn = document.getElementById('create-lobby-btn');
            const joinBtn = document.getElementById('join-lobby-btn');
            const lobbyInput = document.getElementById('join-lobby-input');
            
            createBtn.addEventListener('click', createLobby);
            joinBtn.addEventListener('click', () => joinLobby(lobbyInput.value.toUpperCase()));
        }

        async function createLobby() {
            const lobbyId = Math.random().toString(36).substring(2, 8).toUpperCase();
            const lobbyRef = doc(db, `/artifacts/${appId}/public/data/lobbies-3d/${lobbyId}`);
            await setDoc(lobbyRef, { createdAt: Date.now(), owner: userId });
            await startGame(lobbyId);
        }

        async function joinLobby(lobbyId) {
            if (!lobbyId) {
                document.getElementById('error-message').textContent = 'Please enter a Lobby ID.';
                return;
            }
            const lobbyRef = doc(db, `/artifacts/${appId}/public/data/lobbies-3d/${lobbyId}`);
            const lobbySnap = await getDoc(lobbyRef);

            if (lobbySnap.exists()) {
                await startGame(lobbyId);
            } else {
                document.getElementById('error-message').textContent = 'Lobby not found.';
            }
        }

        async function startGame(lobbyId) {
            if (isGameStarted) return;
            isGameStarted = true;

            currentLobbyId = lobbyId;
            document.getElementById('lobbyId').textContent = lobbyId;
            
            document.getElementById('blocker').style.display = 'none';
            document.getElementById('game-ui-container').style.display = 'flex';
            document.getElementById('version-info').style.display = 'block';
            document.querySelector('.crosshair').style.display = 'block';

            initThree();
            document.body.requestPointerLock();
            
            const startPos = new THREE.Vector3(0, 5, 0);
            camera.position.set(startPos.x, startPos.y, startPos.z);

            const playersCollectionPath = `/artifacts/${appId}/public/data/lobbies-3d/${currentLobbyId}/players`;
            playerRef = doc(db, playersCollectionPath, userId);

            // Immediately create the player document so others can see you
            await setDoc(playerRef, {
                x: camera.position.x,
                y: camera.position.y - 0.8,
                z: camera.position.z,
                qx: camera.quaternion.x,
                qy: camera.quaternion.y,
                qz: camera.quaternion.z,
                qw: camera.quaternion.w,
            });
            
            listenForPlayers(playersCollectionPath);

            animate();
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 150);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.insertBefore(renderer.domElement, document.getElementById('blocker'));
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x606060, 1.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(500, 500);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x66aa66 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Simple obstacles
            for (let i = 0; i < 20; i++) {
                const boxGeo = new THREE.BoxGeometry(10, 20, 10);
                const boxMat = new THREE.MeshLambertMaterial({color: 0xaaaaaa});
                const box = new THREE.Mesh(boxGeo, boxMat);
                box.position.set((Math.random() - 0.5) * 200, 10, (Math.random() - 0.5) * 200);
                box.castShadow = true;
                box.receiveShadow = true;
                scene.add(box);
            }
        }
        
        function listenForPlayers(collectionPath) {
            const playersCollection = collection(db, collectionPath);
            unsubscribeFromPlayers = onSnapshot(playersCollection, (snapshot) => {
                const connectedPlayerIds = new Set();
                snapshot.forEach(doc => connectedPlayerIds.add(doc.id));

                snapshot.docChanges().forEach((change) => {
                    const docId = change.doc.id;
                    const data = change.doc.data();

                    if (docId === userId) return;

                    if (change.type === "added") {
                        if (!playerMeshes[docId]) {
                            const color = PLAYER_COLORS[Object.keys(playerMeshes).length % PLAYER_COLORS.length];
                            const geometry = new THREE.CapsuleGeometry(0.4, 1.0, 4, 8);
                            const material = new THREE.MeshStandardMaterial({ color: color });
                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.castShadow = true;
                            mesh.position.set(data.x, data.y, data.z);
                            playerMeshes[docId] = { mesh, color, targetPosition: new THREE.Vector3(data.x, data.y, data.z), targetQuaternion: new THREE.Quaternion(data.qx, data.qy, data.qz, data.qw) };
                            scene.add(mesh);
                        }
                    }
                    if (change.type === "modified") {
                        if (playerMeshes[docId]) {
                            playerMeshes[docId].targetPosition.set(data.x, data.y, data.z);
                            playerMeshes[docId].targetQuaternion.set(data.qx, data.qy, data.qz, data.qw);
                        }
                    }
                });

                // Clean up disconnected players
                for (const id in playerMeshes) {
                    if (!connectedPlayerIds.has(id)) {
                        scene.remove(playerMeshes[id].mesh);
                        delete playerMeshes[id];
                    }
                }
                updatePlayerListUI();
            });
        }

        function updatePlayerListUI() {
            const list = document.getElementById('player-list');
            list.innerHTML = '';
            // Add self
            const selfLi = document.createElement('li');
            selfLi.innerHTML = `<div class="player-color-indicator" style="background-color: #ffffff"></div> You`;
            list.appendChild(selfLi);

            // Add others
            for (const id in playerMeshes) {
                const player = playerMeshes[id];
                const li = document.createElement('li');
                li.innerHTML = `<div class="player-color-indicator" style="background-color: #${new THREE.Color(player.color).getHexString()}"></div> Player ${id.substring(0,6)}`;
                list.appendChild(li);
            }
        }


        function initEventListeners() {
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement !== document.body) {
                    Object.keys(moveState).forEach(key => moveState[key] = false);
                }
            });
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('keydown', (event) => {
                if (document.pointerLockElement !== document.body) return;
                switch (event.code) {
                    case 'KeyW': moveState.forward = true; break;
                    case 'KeyA': moveState.left = true; break;
                    case 'KeyS': moveState.backward = true; break;
                    case 'KeyD': moveState.right = true; break;
                    case 'ShiftLeft': case 'ShiftRight': moveState.run = true; break;
                    case 'Space': if (canJump) moveState.jump = true; break;
                }
            });
            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW': moveState.forward = false; break;
                    case 'KeyA': moveState.left = false; break;
                    case 'KeyS': moveState.backward = false; break;
                    case 'KeyD': moveState.right = false; break;
                    case 'ShiftLeft': case 'ShiftRight': moveState.run = false; break;
                }
            });
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('beforeunload', () => {
                if (playerRef) deleteDoc(playerRef);
                if (unsubscribeFromPlayers) unsubscribeFromPlayers();
            });
        }

        function onMouseMove(event) {
            if (document.pointerLockElement !== document.body) return;
            camera.rotation.y -= event.movementX * 0.002;
            camera.rotation.x -= event.movementY * 0.002;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }

        function onWindowResize() {
            if (!isGameStarted) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function updatePlayerState(deltaTime) {
            const currentSpeed = moveState.run ? runSpeed : walkSpeed;
            playerVelocity.y += gravity * deltaTime;

            let moveDirection = new THREE.Vector3();
            if (moveState.forward) moveDirection.z = -1;
            if (moveState.backward) moveDirection.z = 1;
            if (moveState.left) moveDirection.x = -1;
            if (moveState.right) moveDirection.x = 1;
            moveDirection.normalize().applyEuler(camera.rotation);

            playerVelocity.x = moveDirection.x * currentSpeed;
            playerVelocity.z = moveDirection.z * currentSpeed;

            if (moveState.jump) {
                playerVelocity.y = jumpForce;
                moveState.jump = false;
                canJump = false;
            }

            camera.position.add(playerVelocity.clone().multiplyScalar(deltaTime));
            
            if (camera.position.y < 1.7) {
                camera.position.y = 1.7;
                playerVelocity.y = 0;
                canJump = true;
            }
        }

        function sendPlayerStateToServer() {
            if (playerRef) {
                setDoc(playerRef, {
                    x: camera.position.x,
                    y: camera.position.y - 0.8, // Position mesh at feet level
                    z: camera.position.z,
                    qx: camera.quaternion.x,
                    qy: camera.quaternion.y,
                    qz: camera.quaternion.z,
                    qw: camera.quaternion.w,
                }, { merge: true });
            }
        }

        function updateRemotePlayers(deltaTime) {
            const interpolationFactor = Math.min(deltaTime * 20, 1.0);
            for (const id in playerMeshes) {
                const player = playerMeshes[id];
                player.mesh.position.lerp(player.targetPosition, interpolationFactor);
                player.mesh.quaternion.slerp(player.targetQuaternion, interpolationFactor);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const deltaTime = (time - lastTime) / 1000;
            
            if (document.pointerLockElement === document.body) {
                updatePlayerState(deltaTime);
                if (time - lastUpdateTime > updateInterval) {
                    sendPlayerStateToServer();
                    lastUpdateTime = time;
                }
            }

            updateRemotePlayers(deltaTime);
            lastTime = time;
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
